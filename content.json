{"meta":{"title":"Deyi Kong","subtitle":"My personal website","description":"I'm a programmer","author":"Deyi Kong","url":"https://deyikong.github.io","root":"/"},"pages":[{"title":"About Me","date":"2022-04-26T23:42:52.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"about/index.html","permalink":"https://deyikong.github.io/about/index.html","excerpt":"","text":"My name is Deyi Kong, pronounced DUH-ee KOANG I like to play basketball, talk to people, hike, etc. This is me. This is my wedding Some crafting with family and friends. img { border-radius: 30px; }"},{"title":"categories","date":"2022-04-28T03:43:49.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"categories/index.html","permalink":"https://deyikong.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2022-04-28T03:47:08.000Z","updated":"2023-02-14T07:34:04.864Z","comments":true,"path":"links/index.html","permalink":"https://deyikong.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2022-04-28T03:44:41.000Z","updated":"2023-02-14T07:34:04.864Z","comments":true,"path":"repository/index.html","permalink":"https://deyikong.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-04-28T03:42:43.000Z","updated":"2023-02-14T07:34:04.864Z","comments":true,"path":"tags/index.html","permalink":"https://deyikong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Island Matrix","slug":"Island-Matrix","date":"2022-05-06T06:39:57.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/05/06/Island-Matrix/","link":"","permalink":"https://deyikong.github.io/2022/05/06/Island-Matrix/","excerpt":"","text":"Union Find Largest Component Size by Common Factor https://leetcode.com/problems/largest-component-size-by-common-factor/ Max Area of Island https://leetcode.com/problems/max-area-of-island/ Solutions dfs bfs union find Making a large Island https://leetcode.com/problems/making-a-large-island/","categories":[],"tags":[]},{"title":"sliding window","slug":"sliding-window","date":"2022-05-06T03:10:43.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/05/06/sliding-window/","link":"","permalink":"https://deyikong.github.io/2022/05/06/sliding-window/","excerpt":"","text":"Thoughts Periodical logic: before k is filled, skip or special case after k is filled, + end, - start. solve sub-problems in the window, it could be maximum, minimum, average in int, average in double, sum(overflow warning) etc. Notes: if it’s a fixed size array, most of the time, we don’t need additional data structures, just the index if it’s a data stream, we might need to save the elements in the window in an array, deque, linkedlist, etc. Method: outline sliding window pick data structure or index focus on inside each window, only three things/steps to do: delete (if fixed size, in order not to be overriden, delete before insert) insert process and save list all the cases for each step might need extra structure, changing states based on inserting and deleting elements, deque Moving Average from Data Stream https://leetcode.com/problems/moving-average-from-data-stream/ Solutions two period: before k values are filled after k values are filled 1234567891011121314151617181920212223242526class MovingAverage &#123; int size = 0; int count = 0; int[] window = null; int sum = 0; int tail = -1; public MovingAverage(int size) &#123; this.size = size; window = new int[size]; &#125; public double next(int val) &#123; // move tail tail = tail == size - 1 ? 0 : tail+1; // delete if (++count &gt; size) &#123; sum -= window[tail]; &#125; // insert window[tail] = val; sum += val; // save return (double)sum / Math.min(count, size); &#125;&#125; 1234567891011121314151617181920212223242526272829class MovingAverage &#123; int size = 0; int curSize = 0; double sum = 0; int i = 0; int[] window = null; public MovingAverage(int size) &#123; this.size = size; window = new int[size]; &#125; public double next(int val) &#123; curSize++; if (curSize &lt;= this.size) &#123; window[curSize - 1] = val; sum+=val; return sum / curSize; &#125; sum -= window[i]; window[i] = val; sum+=val; double res = sum / size; i++; if (i == size) i = 0; return res; &#125;&#125; K Radius Subarray Average https://leetcode.com/problems/k-radius-subarray-averages/ Solutions use end as i, update the middle. could do one pass, or fill with -1 first trick, sum might be overflowing, so use double. 123456789101112131415161718192021222324252627282930class Solution &#123; public int[] getAverages(int[] nums, int k) &#123; double sum = 0; int m = nums.length; int[] res = new int[m]; int windowLength = 2 * k + 1; if (k &gt;= m) &#123; Arrays.fill(res, -1); return res; &#125;; for (int i = 0; i &lt; m; i++) &#123; // before and after if (i &lt; windowLength - 1) &#123; res[i] = -1; sum = nums[i] + sum; continue; &#125; // in between int end = nums[i]; int start = i - windowLength &lt; 0 ? 0 : nums[i - windowLength]; sum = sum + end - start; if (i &gt;= m - k) &#123; res[i] = -1; &#125; res[i - k] = (int)(sum / (double)windowLength); &#125; return res; &#125;&#125; Sliding window maximum https://leetcode.com/problems/sliding-window-maximum/solution/ Solutions pick the right data structure outline the window follow three steps: insert, delete and save idea: monotonous stack/queue 1234567891011121314151617181920212223242526class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; int n = nums.length; int[] ans = new int[n - k + 1]; //. index Deque&lt;Integer&gt; pq = new LinkedList(); for (int i = 0; i &lt; n; i++) &#123; // before k - 1 // insert while (!pq.isEmpty() &amp;&amp; nums[i] &gt; nums[pq.peekLast()]) &#123; pq.pollLast(); &#125; pq.offerLast(i); // delete if (pq.peekFirst() == i - k) pq.pollFirst(); // after k is filled, add local solution to global solution if (i &gt;= k - 1) &#123; ans[i - k + 1] = nums[pq.peek()]; &#125; &#125; return ans; &#125;&#125;","categories":[],"tags":[]},{"title":"Thoughts on OOP","slug":"Thoughts-on-OOP","date":"2022-04-28T01:13:43.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/04/28/Thoughts-on-OOP/","link":"","permalink":"https://deyikong.github.io/2022/04/28/Thoughts-on-OOP/","excerpt":"Object Oriented Programming Guide","text":"How to approach OOP interview questions If you have problems with OOP technical interviews, here are some pointers on how to approach this kind of problems. outline (bottom up): write all the classes/components from small scope to big scope implementation (top down): write all method signatures from big scope to small scope. for the biggest class, start with the constructor, properties and then methods from the requirements(use cases, properties). for the smaller classes, requirements are from their upper classes’ implementation details + initial requirements(use cases, properties). changes (bottom up): if there’s any structural changes(deletion, addition, modification) on a particular part of the code, trace all places that used these changed part bottom up. For example, designing an Excel, each cell has it’s own styles(font, size, color, etc), each cell can have different types of data(integer, string, boolean, etc), users can append or insert rows or columns First step: outline(bottom up)： 123class Cell&lt;T&gt; &#123;&#125;class Row &#123;&#125;class Sheet &#123;&#125; Second Step: implementation (top down): start filling the classes from top down Start with the Sheet’s constructor and some properties, on first thought, we just need an empty constructor 12public Sheet () &#123;&#125; However, because we might need the dimension of the sheet upon constructing, either passed by user or by default. so we need a list of rows first, and the global column. 12345678910111213List&lt;Row&gt; sheet = new ArrayList&lt;Row&gt;();int column;public Sheet () &#123; this(20, 20);&#125;public Sheet (int row, int column) &#123;this.column = column; for (int i = 0; i &lt; row; i++) &#123; sheet.add(new Row(column)); &#125;&#125; Notice, after we finished up the code above, we already added more requirements for the subclass Row like new Row(column). Then based on the requirements, we have appendRow, insertRow, appendColumn, insertColumn 4 functions for sheet, let’s implement them. 1234567891011121314151617181920public void appendRow() &#123; sheet.add(new Row(column));&#125;public void insertRow(int idx) &#123; sheet.add(idx, new Row(column));&#125;// insert and append Colpublic void appendColumn() &#123; for (int j = 0; j &lt; sheet.size(); j++) &#123; sheet.get(j).add(new Cell(&quot;&quot;)); &#125; this.column++; &#125;public void insertColumn(int idx) &#123; for (Row row : sheet) &#123; row.add(idx, new Cell(&quot;&quot;)); &#125; this.column++;&#125; So based on code above, we can conclude the Cell’s constructor signature new Cell(&quot;&quot;), and also Row's method to add a cell row.add(new Cell(&quot;)) Now, let’s move to the next level of class, which is Row. First, let’s start with the constructor, based on the codes we added to Sheet's class, we already have our signature. 12345List&lt;Cell&gt; row = new ArrayList&lt;Cell&gt;();public Row (int column) &#123; for (int i = 0; i &lt; column; i++) row.add(new Cell(&quot;&quot;));&#125; and we also know we need add functions for Row class too, one for appendRow, another for insertRow. 123456public void add(Cell cell) &#123; row.add(cell); &#125;public void add(int idx, Cell cell) &#123; row.add(idx, cell); &#125; That’s it for now for Row Lastly(for now), we need to complete our Cell. Last also start with the constructor, we already know the signature from the code above. 1234T content;public Cell (T content) &#123; this.content = content;&#125; Because we want to add font, size, color, properties to each Cell, let add these here 123String font = &quot;Hei&quot; ;double size = 12;boolean bold = false; That’s pretty much it if that’s all we need to do. However, if we think a little deeper or more realistic, we need a way to update each cell’s data, so let’s do that too. Let’s go top down again from Sheet. add to Sheet123456789public void update(int row, int column, String content) &#123; sheet.get(row).set(column, new Cell&lt;String&gt;(content));&#125;public void update(int row, int column, Integer content) &#123; sheet.get(row).set(column, new Cell&lt;Integer&gt;(content));&#125;public void update(int row, int column, Boolean content) &#123; sheet.get(row).set(column, new Cell&lt;Boolean&gt;(content));&#125; This, in turns, determines one function set for Row, so let’s do that. add to Row123public void set(int col,Cell cell) &#123; row.set(col, cell); &#125; That’s it, if we want to update cells. Third Step: Changes (bottom up) In our current situation, we have font, size and bold in each Cell, however, what if we want to select a range of cells and apply the same style to these Cells. so that requires changes in our Cell class, so let’s create a Style class that’s shared across more than one Cell. 1234567891011121314151617class Cell&lt;T&gt; &#123; Style style; T content; public Cell (T content) &#123; this(content, new Style()); &#125; public Cell (T content, Style style) &#123; this.content = content; this.style = style; &#125;&#125;class Style &#123; String font = &quot;Hei&quot; ; double size = 12; boolean bold = false;&#125; Noticed that we added a style as a constructor param to Cell, you don’t have to add it to the constructor if you want to create a setter(in java) or a property(in C#) or a variable (in PHP). Now, because we changed the cell, we need to go bottom-up styles to fix all the places it sifts up to. Let’s keep a mental queue to add what we need to modify next (just like BFS*). So in Row's constructors, we have two new statements, let’s change that. 12345678public Row (int column) &#123; for (int i = 0; i &lt; column; i++) row.add(new Cell(&quot;&quot;));&#125;public Row (int column, Style style) &#123; for (int i = 0; i &lt; column; i++) row.add(new Cell(&quot;&quot;, style));&#125; We kept the previous constructor and overloaded a new constructor with a Style object for the whole row Let’s keep looking up the usage of Cell while adding Row to the queue to look up next. We found appendColumn, insertColumn and all the updates in Sheet that use Cells constructor, let’s change that. 1234567891011121314151617181920212223242526 // insert and append Col public void appendColumn() &#123; for (int j = 0; j &lt; sheet.size(); j++) &#123; sheet.get(j).add(new Cell(&quot;&quot;, style)); &#125; this.column++; &#125; public void insertColumn(int idx) &#123; for (Row row : sheet) &#123; row.add(idx, new Cell(&quot;&quot;, style)); &#125; this.column++; &#125;// update public void update(int row, int column, String content) &#123; Style s = sheet.get(row).get(column).style; sheet.get(row).set(column, new Cell&lt;String&gt;(content, s)); &#125; public void update(int row, int column, Integer content) &#123; Style s = sheet.get(row).get(column).style; sheet.get(row).set(column, new Cell&lt;Integer&gt;(content, s)); &#125; public void update(int row, int column, Boolean content) &#123; Style s = sheet.get(row).get(column).style; sheet.get(row).set(column, new Cell&lt;Boolean&gt;(content, s)); &#125; Notice that when we update, we keep the old style and assign it to the new cell created. Also, this means we need to have a global style in the sheet, and initialize the style in the constructor. 1234567891011Style style;public Sheet () &#123; this(20, 20);&#125;public Sheet (int row, int column) &#123; this.column = column; style = new Style(); for (int i = 0; i &lt; row; i++) &#123; sheet.add(new Row(column)); &#125;&#125; After that, we are done with Cell's changes(bottom up), but we are done yet, remember, we added the Row's constructor to the queue, now let’s look at the places where Row's constructor is used. We found the usages in Sheet's constructor, appendRow and insertRow. For the Sheet's constructor, either we update it to sheet.add(new Row(column, style)) or just keep what it is if you don’t care about the extra same styles created for each Cell. A better solution is sharing the same style, so let’s do that. 1234567public Sheet (int row, int column) &#123; this.column = column; style = new Style(); for (int i = 0; i &lt; row; i++) &#123; sheet.add(new Row(column, style)); &#125;&#125; for appendRow, and insertRow, let’s change them. 1234567// insert and append Rowpublic void appendRow() &#123; sheet.add(new Row(column, style));&#125;public void insertRow(int idx) &#123; sheet.add(idx, new Row(column, style));&#125; Since this is the biggest class, they are not used anywhere, so we don’t need to add the changes to the queue(that’s not always the case though). So the queue is empty now, so that means we are done with the effect by extracting styles to a Style object. Viola, that’s it. If you want to read the complete code, here’s the link, I also added codes to apply styles to a range of cells over there. Notes *Overall programming habit, BFS: don’t program too deep when there’s a thought, just go down 1 step down and just write the signature and keep writing.","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://deyikong.github.io/tags/interview/"},{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"OOP","slug":"OOP","permalink":"https://deyikong.github.io/tags/OOP/"}]},{"title":"Kth Biggest","slug":"Kth-Biggest","date":"2022-04-21T02:13:31.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/04/21/Kth-Biggest/","link":"","permalink":"https://deyikong.github.io/2022/04/21/Kth-Biggest/","excerpt":"","text":"Kth Largest Element in an Array https://leetcode.com/problems/kth-largest-element-in-an-array/ Solutions sort max heap min heap quick select min heap12345678910111213141516class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;Integer&gt;((a, b) -&gt; a - b); for (int i = 0; i &lt; k; i++) &#123; pq.add(nums[i]); &#125; for (int i = k; i &lt; nums.length; i++) &#123; int top = pq.peek(); if (nums[i] &gt; top) &#123; pq.poll(); pq.add(nums[i]); &#125; &#125; return pq.peek(); &#125;&#125; quickselect1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int findKthLargest(int[] nums, int k) &#123; int start = 0, end = nums.length - 1; while (start &lt;= end) &#123; int p = partition(nums, start, end); if (p == k - 1) &#123; return nums[p]; &#125; if (p &gt; k - 1) &#123; end = p - 1; &#125; if (p &lt; k - 1) &#123; start = p + 1; &#125; &#125; return -1; &#125; private int partition(int[] nums, int s, int e) &#123; if (s == e) return s; int p = nums[e]; int i = s - 1, j = s; //loop invariant, left of i is all smaller than p, including i. between i and j are all bigger than p while (j &lt; e) &#123; if (nums[j] &gt; p) &#123; i++; swap(nums, i, j); &#125; j++; &#125; swap(nums, i+1, e); return i + 1; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125;","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"kth biggest","slug":"kth-biggest","permalink":"https://deyikong.github.io/tags/kth-biggest/"}]},{"title":"Bucket Sort","slug":"Bucket-Sort-And-Meeting-Rooms","date":"2022-04-12T05:05:41.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/04/12/Bucket-Sort-And-Meeting-Rooms/","link":"","permalink":"https://deyikong.github.io/2022/04/12/Bucket-Sort-And-Meeting-Rooms/","excerpt":"","text":"扫描线问题 Line Sweep Range Addition https://leetcode.com/problems/range-addition/ Solutions S1. normal O(n * k) S2. only update start and end+1 to get an array of difference, O(n + k), how to come up with this thought: loop order from left to right, order plays a key part record the difference 1234567891011121314151617class Solution &#123; public int[] getModifiedArray(int length, int[][] updates) &#123; int[] res = new int[length]; int l = updates.length; for (int i = 0; i &lt; l; i++) &#123; res[updates[i][0]] += updates[i][2]; if (updates[i][1] + 1 &lt; length) &#123; res[updates[i][1] + 1] -= updates[i][2]; &#125; &#125; for (int i = 1; i &lt; length; i++) &#123; res[i] = res[i - 1] + res[i]; &#125; return res; &#125;&#125; Similar problem as above, Car Pooling https://leetcode.com/problems/car-pooling/ Solutions bucket sort timestamp, TreeMap 123456789101112131415161718class Solution &#123; public boolean carPooling(int[][] trips, int capacity) &#123; int[] res = new int[1000]; for (int i = 0; i &lt; trips.length; i++) &#123; if (trips[i][0] &gt; capacity) return false; res[trips[i][1] - 1] += trips[i][0]; res[trips[i][2] - 1] -= trips[i][0]; &#125; for (int i = 1; i &lt; res.length; i++) &#123; res[i] = res[i - 1] + res[i]; if (res[i] &gt; capacity) &#123; return false; &#125; &#125; return true; &#125;&#125; 123456789101112131415161718class Solution &#123; public boolean carPooling(int[][] trips, int capacity) &#123; Map&lt;Integer, Integer&gt; timestamps = new TreeMap(); for (int i = 0; i &lt; trips.length; i++) &#123; if (trips[i][0] &gt; capacity) return false; timestamps.put(trips[i][1], timestamps.getOrDefault(trips[i][1], 0) + trips[i][0]); timestamps.put(trips[i][2], timestamps.getOrDefault(trips[i][2], 0) - trips[i][0]); &#125; int usedCapacity = 0; for (int change : timestamps.values()) &#123; usedCapacity += change; if (usedCapacity &gt; capacity) return false; &#125; return true; &#125;&#125; Corporate Flight Booking https://leetcode.com/problems/corporate-flight-bookings/ Solutions same as above Meeting Room II https://leetcode.com/problems/meeting-rooms-ii/ Solutions TreeMap PriorityQueue 1234567891011121314151617class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; Map&lt;Integer, Integer&gt; timestamps = new TreeMap(); for (int[] interval: intervals) &#123; timestamps.put(interval[0], timestamps.getOrDefault(interval[0], 0) + 1); timestamps.put(interval[1], timestamps.getOrDefault(interval[1], 0) - 1); &#125; int last = 0; int max = 0; for (int timestamp : timestamps.values()) &#123; last += timestamp; max = Math.max(max, last); &#125; return max; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; // base case, if there&#x27;s no intervals, return 0 if (intervals.length == 0) return 0; // min heap PriorityQueue&lt;Integer&gt; allocator = new PriorityQueue&lt;Integer&gt;( intervals.length, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer a, Integer b) &#123; return a - b; &#125; &#125; ); //Sort the intervals by start time Arrays.sort( intervals, new Comparator&lt;int[]&gt;() &#123; public int compare(int[] a, int[] b) &#123; return a[0] - b[0]; &#125; &#125; ); // add the first meeting allocator.add(intervals[0][1]); //Interate over remaining intervals for (int i = 1; i &lt; intervals.length; i++) &#123; // If the earliest room is free, assign this room to this meeting if (intervals[i][0] &gt;= allocator.peek()) &#123; allocator.poll(); &#125; //if a new room is to be assigned, add it to the heap. allocator.add(intervals[i][1]); &#125; return allocator.size(); &#125;&#125; 252 meeting room https://leetcode.com/problems/meeting-rooms/ 253 meeting room II https://leetcode.com/problems/meeting-rooms-ii/ 56 merge interval https://leetcode.com/problems/merge-intervals/ 1272 Remove interval https://leetcode.com/problems/remove-interval/ 435 non overlapping intervals https://leetcode.com/problems/non-overlapping-intervals/ 1288 Remove Covered intervals https://leetcode.com/problems/remove-covered-intervals/ 1229 Meeting Scheduler https://leetcode.com/problems/meeting-scheduler/ 986 interval list intersections https://leetcode.com/problems/interval-list-intersections/ 759 Employee Free Time https://leetcode.com/problems/employee-free-time/","categories":[],"tags":[]},{"title":"Problems","slug":"Problems","date":"2022-04-05T16:32:04.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/04/05/Problems/","link":"","permalink":"https://deyikong.github.io/2022/04/05/Problems/","excerpt":"","text":"04/05/2022 Longest Common Prefix https://leetcode.com/problems/longest-common-prefix/ Solutions: horizontal scanning(from left to right) vertical scanning(compare the ith char on all the elements each time) divide and conquer Binary search Follow up LCP called multiple times frequently use a trie node path must only have one child element stop at the “isWord” node must match the character Letter Combinations of a phone number https://leetcode.com/problems/letter-combinations-of-a-phone-number/ Solutions: backtracking DFS Remove Nth Node From End of List https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Solutions two pass, one to find the length, the other to find the first Node. Generate Parentheses https://leetcode.com/problems/generate-parentheses/ DFS(permutation: only allow certain paths when conditions met) Closure Number: (To be reviewed) swap nodes in pairs https://leetcode.com/problems/swap-nodes-in-pairs/ set up loop invariant and keep them. prev, first, second. remove element https://leetcode.com/problems/remove-element/ Solutions two pointer, slow fast pointer. copy over all the not equal elements two pointer, opposite direction, reduce right pointer by one when equal. implement strstr https://leetcode.com/problems/implement-strstr/ 12345678910111213141516public int strStr(String haystack, String needle) &#123; int index = 0; char[] hays = haystack.toCharArray(); char[] needles = needle.toCharArray(); int i = 0; for (; i &lt; hays.length; i++) &#123; int j = 0; while (j &lt; needles.length &amp;&amp; i+j &lt; hays.length &amp;&amp; hays[i+j] == needles[j]) &#123; j++; &#125; if (j == needles.length) &#123; return i; &#125; &#125; return -1; &#125; Find First and Last Position of Element in Sorted Array https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/ solutions binary search two ends. stop at two elements, because we might get into a dead loop. Count and Say https://leetcode.com/problems/count-and-say/ 123456789101112131415161718192021222324252627public String countAndSay(int n) &#123; if (n == 1) &#123; return &quot;1&quot;; &#125; String prev = &quot;11&quot;; for (int i = 1; i &lt; n - 1; i++) &#123; prev = convert(prev); &#125; return prev; &#125; private String convert(String prev) &#123; StringBuilder sb = new StringBuilder(); char[] chars = prev.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; char c = chars[i]; int count = 1; while (i+1 &lt; chars.length &amp;&amp; chars[i+1] == c) &#123; count++; i++; &#125; sb.append(count); sb.append(c); &#125; return sb.toString(); &#125; Combination Sum https://leetcode.com/problems/combination-sum/ 1234567891011121314151617181920212223242526272829class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; combine(candidates, 0, target, new ArrayList&lt;Integer&gt;()); return res; &#125; private void combine(int[] candidates, int level, int target, List&lt;Integer&gt; list) &#123; if (target == 0) &#123; res.add(list); return; &#125; if (level == candidates.length) &#123; return; &#125; int count = 0; while(count * candidates[level] &lt;= target) &#123; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); for (int i = 0; i &lt; count; i++) &#123; copy.add(candidates[level]); &#125; combine(candidates, level + 1, target - count * candidates[level], copy); count++; &#125; &#125;&#125; Jump game II https://leetcode.com/problems/jump-game-ii/ Solutions dp N^2 BFS, N greedy 04/06/2022 Permutations https://leetcode.com/problems/permutations/ Solutions key point: fill each spot with available elements dps swap swap Combination Sum II https://leetcode.com/problems/combination-sum-ii/ Solutions think of each element can only show up on a level repeated times 123456789101112131415161718192021222324252627282930313233343536List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; int sum = Arrays.stream(candidates).sum(); if (target &gt; sum) &#123; return res; &#125; Arrays.sort(candidates); dps(candidates, target, 0, new ArrayList&lt;Integer&gt;()); return res;&#125;private void dps(int[] candidates, int target, int idx, List&lt;Integer&gt; list) &#123; if (target == 0) &#123; res.add(list); return; &#125; if (idx &gt;= candidates.length) &#123; return; &#125; int nextUnique = idx + 1; int count = 1; while (nextUnique &lt; candidates.length &amp;&amp; candidates[nextUnique] == candidates[idx]) &#123; nextUnique++; count++; &#125; for (int i = 0; i &lt;= count; i++) &#123; int rem = target - i * candidates[idx]; if (rem &lt; 0) return; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); for (int j = 0; j &lt; i; j++) &#123; copy.add(candidates[idx]); &#125; dps(candidates, rem, nextUnique, copy); &#125;&#125; Permutations II (with duplicated elements) https://leetcode.com/problems/permutations-ii/ Solutions sort array use a set to check on each level to see if the element was added already 12345678910111213141516171819202122232425262728293031323334List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123; Arrays.sort(nums); permute(nums, 0); return res;&#125;private void permute(int[] nums, int idx) &#123; int n = nums.length; if (idx == n) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; list.add(nums[i]); &#125; res.add(list); return; &#125; HashSet&lt;Integer&gt; set = new HashSet(); // not adding current for (int k = idx; k &lt; n; k++) &#123; if (set.contains(nums[k])) &#123; continue; &#125; swap(nums, idx, k); permute(nums, idx + 1); swap(nums, idx, k); set.add(nums[k]); &#125;&#125;private void swap(int[] nums, int i, int j) &#123; int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp;&#125; Power(x, n) https://leetcode.com/problems/powx-n/ Solutions cut in half each time, dp to remember half. check negative and odd situation 123456789101112131415161718192021public double myPow(double x, int n) &#123; if (n &lt; 0) &#123; return 1 / helper(x, -n); &#125; return helper(x, n); &#125; public double helper(double x, int n) &#123; if (n == 0) &#123; return 1; &#125; if (n == 1) &#123; return x; &#125; int half = n / 2; double halfValue = helper(x, half); int mod = n % 2; if (mod != 0) &#123; return halfValue * halfValue * x; &#125; return halfValue * halfValue; &#125; Spiral Matrix https://leetcode.com/problems/spiral-matrix/ Solutions separate directions check boundary 123456789101112131415161718192021222324252627282930313233343536373839404142434445public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); int row = matrix.length; int col = matrix[0].length; int layers = (Math.min(row, col) + 1) / 2; for (int i = 0; i &lt; layers; i++) &#123; int innerRow = row - 2 * i; int innerCol = col - 2 * i; if (innerCol == 1) &#123; for (int j = 0; j &lt; innerRow; j++) &#123; res.add(matrix[i + j][i]); &#125; return res; &#125; if (innerRow == 1) &#123; for (int j = 0; j &lt; innerCol; j++) &#123; res.add(matrix[i][i + j]); &#125; return res; &#125; // print top line for (int j = 0; j &lt; innerCol - 1; j++) &#123; res.add(matrix[i][i + j]); &#125; // print right line if (col - i - 1 &gt; 0) &#123; for (int j = 0; j &lt; innerRow - 1; j++) &#123; res.add(matrix[i + j][col - i -1]); &#125; &#125; // print bottom line if (row - i - 1 &gt; 0) &#123; for (int j = 0; j &lt; innerCol - 1; j++) &#123; res.add(matrix[row - i - 1][col - i - 1 - j]); &#125; &#125; // print left line if (i &lt; col) &#123; for (int j = 0; j &lt; innerRow - 1; j++) &#123; res.add(matrix[row - i - 1 - j][i]); &#125; &#125; &#125; return res; &#125; Jump Game https://leetcode.com/problems/jump-game/ Solutions go from left to right remember last reachable element 1234567891011121314public boolean canJump(int[] nums) &#123; int n = nums.length; if (n &lt;= 1) return true; int last = 0; for (int i = 0; i &lt; n; i++) &#123; if (i &gt; last) return false; int next = nums[i] + i; if (next &gt;= n - 1) &#123; return true; &#125; last = Math.max(next, last); &#125; return false; &#125; Spiral Matrix II (fill out a matrix spirally ) https://leetcode.com/problems/spiral-matrix-ii/ Solutions different directions 123456789101112131415161718192021222324252627282930public int[][] generateMatrix(int n) &#123; int total = n * n; int count = 1; int layers = (n + 1) / 2; int[][] res = new int[n][n]; for (int i = 0; i &lt; layers; i++) &#123; int l = n - 2 * i; if (l == 1) &#123; res[i][i] = count; &#125; // top for (int j = 0; j &lt; l - 1; j++) &#123; res[i][i + j] = count++; &#125; // right for (int j = 0; j &lt; l - 1; j++) &#123; res[i + j][n - i - 1] = count++; &#125; // bottom for (int j = 0; j &lt; l - 1; j++) &#123; res[n - i - 1][n - i - 1 - j] = count++; &#125; // left for (int j = 0; j &lt; l - 1; j++) &#123; res[n - i - 1 - j][i] = count++; &#125; &#125; return res; &#125; unique paths https://leetcode.com/problems/unique-paths/ Solutions dp basic math: choose m - 1 or n - 1 from m - n - 2 unique paths II (with obstacles) https://leetcode.com/problems/unique-paths-ii/ solutions dp 123456789101112131415161718192021public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int m = obstacleGrid.length; int n = obstacleGrid[0].length; if (obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0; int[][] dp = new int[m][n]; dp[0][0] = 1; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; if (obstacleGrid[i][j] == 1) &#123; dp[i][j] = 0; &#125; else &#123; int left = j == 0 ? 0 : dp[i][j-1]; int up = i == 0 ? 0 : dp[i - 1][j]; dp[i][j] = left + up; &#125; &#125; &#125; return dp[m-1][n-1];&#125; Minimum path sum https://leetcode.com/problems/minimum-path-sum/ Solutions dp 2D dp 1D 12345678910111213141516public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; int left = j == 0 ? Integer.MAX_VALUE : dp[i][j-1]; int up = i == 0 ? Integer.MAX_VALUE : dp[i - 1][j]; dp[i][j] = Math.min(left, up) + grid[i][j]; &#125; &#125; return dp[m - 1][n - 1];&#125; 1234567891011121314151617181920public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[] dp = new int[n]; dp[0] = grid[0][0]; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == 0 &amp;&amp; j == 0) continue; if (j == 0) &#123; dp[j] = dp[j] + grid[i][j]; continue; &#125; int left = j == 0 ? Integer.MAX_VALUE : dp[j - 1]; int up = i == 0 ? Integer.MAX_VALUE : dp[j]; dp[j] = Math.min(left, up) + grid[i][j]; &#125; &#125; return dp[n - 1];&#125; Set Matrix Zeros https://leetcode.com/problems/set-matrix-zeroes/ solutions use two sets use first column and first row as marker search a 2d matrix https://leetcode.com/problems/search-a-2d-matrix/ Solutions get row and col like: mid / n; mid % n; 123456789101112131415161718192021public boolean searchMatrix(int[][] matrix, int target) &#123; int m = matrix.length; int n = matrix[0].length; int l = 0, r = m * n - 1; while (l &lt;= r) &#123; int mid = l + (r - l)/2; int row = mid / n; int col = mid % n; if (matrix[row][col] == target) &#123; return true; &#125; if (matrix[row][col] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return false;&#125; 04/07/2022 Sort color https://leetcode.com/problems/sort-colors/ Solutions quicksort O(NlogN) (more general) O(N), one pass solution loop invariants: three pointers, left i and right j, and cur left elements of i are all zeros right elements of j are all twos elements between i and j are all ones including i and j (this is not needed) initialization: start at cur = 0, i = 0, j = nums.length -1; maintenance: if nums[cur] = 0, move it to the left of i, so swap with i and then move i to the right, then move cur to the right by one too. if nums[cur] = 2, move it to the right of j, so swap with j and then move j to the left. if nums[cur] = 1, ignore i or j, move cur to the right by one. termination: cur &gt; j 12345678910111213141516171819202122public void sortColors(int[] nums) &#123; int i = 0, j = nums.length -1, cur = 0; while (cur &lt;= j) &#123; if (nums[cur] == 2) &#123; swap(nums, cur, j); j--; continue; &#125; if (nums[cur] == 0) &#123; swap(nums, cur, i); i++; cur++; continue; &#125; cur++; &#125; &#125; private void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; Subsets https://leetcode.com/problems/subsets/ solutions backtracking (needs review) dps, each level with or without the current element 1234567891011121314151617181920class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; dps(nums, 0, new ArrayList&lt;Integer&gt;()); return res; &#125; private void dps(int[] nums, int idx, List&lt;Integer&gt; list) &#123; if (idx == nums.length) &#123; res.add(list); return; &#125; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); dps(nums, idx + 1, copy); List&lt;Integer&gt; copy2 = new ArrayList&lt;Integer&gt;(list); copy2.add(nums[idx]); dps(nums, idx + 1, copy2); &#125;&#125; Word search https://leetcode.com/problems/word-search/ solutions mark visited grid ‘#’ and then change it back after dps pruning before dps would save time: check if word’s length is longer than total number of elements in grid check if there’s any element that’s not in the grid 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public boolean exist(char[][] board, String word) &#123; int m = board.length; int n = board[0].length; if (word.length() &gt; m * n) return false; HashSet&lt;Character&gt; uniqueChars = new HashSet(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; uniqueChars.add(board[i][j]); &#125; &#125; for (int i = 0; i &lt; word.length(); i++) &#123; if (!uniqueChars.contains(word.charAt(i))) &#123; return false; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == word.charAt(0)) &#123; boolean exist = checkWord(board, i, j, word, 0); if (exist) return true; &#125; &#125; &#125; return false; &#125; private boolean checkWord(char[][] board, int i, int j, String word, int idx) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length) return false; if (board[i][j] == word.charAt(idx))&#123; if (idx == word.length() - 1) &#123; return true; &#125; board[i][j] = &#x27;#&#x27;; boolean up = checkWord(board, i - 1, j, word, idx + 1); boolean left = checkWord(board, i, j - 1, word, idx + 1); boolean down = checkWord(board, i + 1, j, word, idx + 1); boolean right = checkWord(board, i, j + 1, word, idx + 1); board[i][j] = word.charAt(idx); return up || left || down || right; &#125; return false; &#125;&#125; Remove duplicates from sorted array II https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ Solutions copy the last two elements of its kind instead of the first two because it might be overriden. 123456789101112class Solution &#123; public int removeDuplicates(int[] nums) &#123; int i = 0, j = 0; for (; j &lt; nums.length; j++) &#123; if (j + 2 &gt;= nums.length || nums[j] != nums[j + 2]) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i; &#125;&#125; #04/08/2022 search in rotated sorted array https://leetcode.com/problems/search-in-rotated-sorted-array/ solutions S1. find the pivot first, then binary search one of them S2. one binary search, add more conditions to move left or right 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123; public int search(int[] nums, int target) &#123; int m = nums.length; if (m == 0) return -1; int first = nums[0]; if (target == first) return 0; int start = 0, end = m - 1; int last = 0; while (start &lt;= end) &#123; int mid = start + (end - start) / 2; if (nums[mid] == target) return mid; if (mid + 1 &lt; m &amp;&amp; nums[mid] &gt; nums[mid + 1]) &#123; last = mid; break; &#125; if (nums[mid] &gt;= first)&#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; // first half if (target &gt; first) &#123; return binarySearch(nums, 0, last == 0 ? m - 1 : last, target); &#125; else &#123; // last half return binarySearch(nums, last + 1, m - 1, target); &#125; &#125; private int binarySearch(int[] nums, int l, int r, int target) &#123; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] == target) return mid; if (nums[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length-1; while(left&lt;=right) &#123; int mid = left + (right-left)/2; if(target == nums[mid]) &#123; return mid; &#125; if(nums[mid] &lt;= nums[right]) &#123; if(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right]) &#123; left = mid +1; &#125;else&#123; right = mid -1; &#125; &#125;else&#123; if(target&lt;nums[mid]&amp;&amp;target&gt;=nums[left])&#123; right = mid - 1; &#125;else&#123; left = mid + 1; &#125; &#125; &#125; return -1; &#125;&#125; Search in Rotated Sorted Array II https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ Solutions same as the first one except when trying to locate pivot, check which side the pivot it located in by checking to the right or left 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; public boolean search(int[] nums, int target) &#123; int m = nums.length; if (m == 0) return false; int first = nums[0]; if (target == first) return true; int start = 0, end = m - 1; int last = 0; while (start &lt;= end) &#123; int mid = start + (end - start) / 2; if (nums[mid] == target) return true; if (mid + 1 &lt; m &amp;&amp; nums[mid] &gt; nums[mid + 1]) &#123; last = mid; break; &#125; if (nums[mid] == first) &#123; int count = mid + 1; while(count &lt; m &amp;&amp; nums[count] == nums[mid]) &#123; count++; &#125; if (count == m) &#123; end = mid - 1; &#125; else &#123; start = mid + 1; &#125; &#125; else if (nums[mid] &gt; first)&#123; start = mid + 1; &#125; else &#123; end = mid - 1; &#125; &#125; // first half if (target &gt; first) &#123; return binarySearch(nums, 0, last == 0 ? m - 1 : last, target); &#125; else &#123; // last half return binarySearch(nums, last + 1, m - 1, target); &#125; &#125; private boolean binarySearch(int[] nums, int l, int r, int target) &#123; while (l &lt;= r) &#123; int mid = l + (r - l) / 2; if (nums[mid] == target) return true; if (nums[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return false; &#125;&#125; Remove Duplicates from Sorted List https://leetcode.com/problems/remove-duplicates-from-sorted-list/ Solutions two pointer, prev and cur loop invariants: everything left to prev including prev are all unique move cur to the right without connecting if it’s the same as prev Remove Duplicates from Sorted List II https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution/ Solutions Sentinel head solution: dummy head, because we are not sure what’s the head, so we check which is head first, then append it to the dummy head. loop invariants: everything left to last are correct answer set last.next to the first element of its kind, and then override it if it’s not the only element of its kind move “last” if current element is different than the last element 123456789101112131415161718192021222324class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; //loop invariants: cur if (head == null || head.next == null) return head; ListNode dummy = new ListNode(0, head); ListNode last = dummy; ListNode cur = head; while (cur != null) &#123; // if two are the same if (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; // skip all duplicates while (cur.next != null &amp;&amp; cur.val == cur.next.val) &#123; cur = cur.next; &#125; last.next = cur.next; &#125; else &#123; // two are not the same last = last.next; &#125; // must have cur = cur.next; &#125; return dummy.next; &#125;&#125; subsets ii https://leetcode.com/problems/subsets-ii/submissions/ Solutions skip the dps level for the same elements. so for duplicated levels, add different number of elements there trick: set count to 1, and loop at least 0 and 1. if ther’s more, loop extra. 1234567891011121314151617181920212223242526class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123; Arrays.sort(nums); dps(nums, 0, new ArrayList&lt;Integer&gt;()); return res; &#125; private void dps(int[] nums, int idx, List&lt;Integer&gt; list) &#123; int m = nums.length; if (idx == m) &#123; res.add(list); return; &#125; int count = 1; while (idx+count &lt; m &amp;&amp; nums[idx] == nums[idx + count]) &#123; count++; &#125; List&lt;Integer&gt; copy = new ArrayList&lt;Integer&gt;(list); for (int i = 0; i &lt;= count; i++) &#123; dps(nums, idx + count, copy); copy = new ArrayList&lt;Integer&gt;(copy); copy.add(nums[idx]); &#125; &#125;&#125; Reverse LinkedList II https://leetcode.com/problems/reverse-linked-list-ii/ trick part, remember the element before the reversal, and also the element where the reversal stops. Solutions use dummy head, because we don’t know the new head ahead of time record “newHead” and “newTail” and “before” 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public ListNode reverseBetween(ListNode head, int left, int right) &#123; ListNode dummy = new ListNode(); dummy.next = head; ListNode before = head; ListNode cur = head; int count = 1; while (cur != null) &#123; if (count == left - 1) &#123; before = cur; &#125; else if (count == left) &#123; ListNode newHead = head; ListNode newTail = head; ListNode reverseHead = cur; newTail = cur; ListNode prev = null; while (count &lt;= right) &#123; if (count == right) &#123; newHead = reverseHead; &#125; ListNode next = reverseHead.next; reverseHead.next = prev; prev = reverseHead; count++; reverseHead = next; &#125; newTail.next = reverseHead; if (left == 1) &#123; dummy.next = newHead; &#125; else &#123; before.next = newHead; &#125; return dummy.next; &#125; cur = cur.next; count++; &#125; return dummy.next; &#125;&#125; Restore IP Address https://leetcode.com/problems/restore-ip-addresses/ Solutions backtrack (my prefered dps way) 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) &#123; char[] chars = s.toCharArray(); dps(chars, 0, 1, &quot;&quot;); return res; &#125; private void dps(char[] chars, int idx, int count, String s) &#123; int m = chars.length; if (count == 4) &#123; if (idx &gt;= m) return; int lastNumber = 0; if (Character.getNumericValue(chars[idx]) == 0 &amp;&amp; idx != m-1) return; while (idx &lt; m) &#123; int tempNum = Character.getNumericValue(chars[idx]); lastNumber = lastNumber * 10 + tempNum; idx++; if(lastNumber &gt; 255) return; &#125; res.add(s + lastNumber); return; &#125; if (idx == m) return; //if (!Character.isDigit(chars[idx])) return; int num = Character.getNumericValue(chars[idx]); if (num == 0) &#123; dps(chars, ++idx, count+1, s + num + &quot;.&quot;); return; &#125;; while (idx &lt; m &amp;&amp; num &lt;= 255) &#123; dps(chars, ++idx, count+1, s + num + &quot;.&quot;); if (idx &gt;=m) return; int tempNum = Character.getNumericValue(chars[idx]); num = num * 10 + tempNum; &#125; &#125;&#125; Flip String to Monotone increasing https://leetcode.com/problems/flip-string-to-monotone-increasing/ Solutions s1. check how many 0s before element and how many zeros after element i using prefix sum s2. very tricky thought process, dp thought process too if current element is 1 not flip it, stays 1, so flips[i] = flips[i - 1] flip it to 0, flips = flips[i] = previous ones + 1 get min if current element is 0 not flipping it, stay 0, flips[i] = flips[i - 1] flip it to 1, then flips[i] = flips[i - 1] + 1, because previous doesnt’ need to change. get min 12345678910111213141516class Solution &#123; public int minFlipsMonoIncr(String s) &#123; int one = 0; int flip =0; for(int i=0;i&lt;s.length();i++) &#123; if(s.charAt(i)==&#x27;1&#x27;) &#123; one++; &#125; else &#123; flip++; &#125; flip = Math.min(one,flip); &#125; return flip; &#125;&#125; Count Unique Characters of All Substrings of a Given String https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/ Solutions S1. count contributions between last two same character: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/C%2B%2BJavaPython-One-pass-O(N) S2. remember lastIndex and contribution of each character: https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/129021/O(N)-Java-Solution-DP-Clear-and-easy-to-Understand Sum of Subarray Ranges https://leetcode.com/problems/sum-of-subarray-ranges/ Solutions S1. O(n^2), for for loop S2. O(n) (to be reviewed) https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624222/JavaC%2B%2BPython-O(n)-solution-detailed-explanation #04/10/2022 LRU Cache https://leetcode.com/problems/lru-cache/ Solutions Node has “prev” and “next” pointer so the removal is easier Have two dummy node “head” and “tail”, change everything in between so that we don’t have check if it’s the head or tail separate methods to smaller ones popHead appendToEnd removeNode 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class LRUCache &#123; class Node &#123; int key = 0, val = 0; Node next, prev; public Node (int key, int val) &#123; this.key = key; this.val = val; &#125; public Node () &#123; this(0, 0); &#125; &#125; HashMap&lt;Integer, Node&gt; map; int capacity = 0; Node head, tail; public LRUCache(int capacity) &#123; this.capacity = capacity; this.map = new HashMap(); this.head = new Node(); this.tail = new Node(); head.next = tail; tail.prev = head; &#125; public int get(int key) &#123; if(!map.containsKey(key)) return -1; Node node = map.get(key); moveNodeToEnd(node); return node.val; &#125; public void put(int key, int value) &#123; if (map.containsKey(key)) &#123; Node node = map.get(key); node.val = value; moveNodeToEnd(node); return; &#125; if (map.size() == capacity) removeHead(); Node node = new Node(key, value); map.put(key, node); appendNode(node); &#125; private void moveNodeToEnd(Node node) &#123; removeNode(node); appendNode(node); &#125; private void removeHead() &#123; head = head.next; head.prev = null; map.remove(head.key); head.key = 0; head.val = 0; &#125; private void appendNode(Node node) &#123; Node prev = tail.prev; prev.next = node; node.prev = prev; tail.prev = node; node.next = tail; &#125; private void removeNode(Node node) &#123; Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; node.next = null; node.prev = null; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Count Binary Substrings https://leetcode.com/problems/count-binary-substrings/ Solutions count ones and zeros, take min of the two consecutive groups 12345678910111213141516171819class Solution &#123; public int countBinarySubstrings(String s) &#123; if (s.length() == 0) return 0; int prev = 0; int cur = 1; int res = 0; for (int i = 1; i &lt; s.length(); i++) &#123; if (s.charAt(i) == s.charAt(i - 1)) &#123; cur++; &#125; else &#123; res += Math.min(prev, cur); prev = cur; cur = 1; &#125; &#125; return res + Math.min(prev, cur); &#125;&#125; The kth Factor of n https://leetcode.com/problems/the-kth-factor-of-n/ Solutions O(sqrt(N)) S1. remember both halves. S2. check if the k is in the first half, only save divisors 12345678910111213141516171819202122232425class Solution &#123; public int kthFactor(int n, int k) &#123; int count = 1; List&lt;Integer&gt; secondHalf = new ArrayList(); int i = 1; int j = n; do &#123; int mod = n % i; if (mod == 0) &#123; if (k == 1) &#123; return i; &#125; j = n / i; if (i != j) &#123; secondHalf.add(j); &#125; k--; &#125; i++; &#125; while (i &lt; j); int size = secondHalf.size(); if (k &gt; size) return -1; return secondHalf.get(size - k); &#125;&#125; 12345678910111213141516171819202122232425class Solution &#123; public int kthFactor(int n, int k) &#123; int count = 1; List&lt;Integer&gt; firstHalf = new ArrayList(); List&lt;Integer&gt; secondHalf = new ArrayList(); int i = 1; int j = n; do &#123; int mod = n % i; if (mod == 0) &#123; firstHalf.add(i); j = n / i; if (i != j) &#123; secondHalf.add(j); &#125; &#125; i++; &#125; while (i &lt; j); int size1 = firstHalf.size(); if (k &lt;= size1) return firstHalf.get(k - 1); int size2 = secondHalf.size(); if (k &gt; size1 + size2) return -1; return secondHalf.get(size2 - (k - size1)); &#125;&#125; valid palindrome II https://leetcode.com/problems/valid-palindrome-ii/ Solutions try both substrings generated by deleting each of the mismatched pair 12345678910111213141516171819202122232425class Solution &#123; public boolean validPalindrome(String s) &#123; int i = 0; int j = s.length() - 1; int count = 1; while (i &lt; j) &#123; if (s.charAt(i) != s.charAt(j)) &#123; return checkPalindrom(s, i, j-1) || checkPalindrom(s, i+1, j); &#125; i++; j--; &#125; return true; &#125; private boolean checkPalindrom(String s, int i, int j) &#123; while (i &lt; j) &#123; if (s.charAt(i) != s.charAt(j)) &#123; return false; &#125; i++; j--; &#125; return true; &#125;&#125; Maximum Units on a Truck https://leetcode.com/problems/maximum-units-on-a-truck/ Solutions sort the array and pick from the bigger box first. 1234567891011121314class Solution &#123; public int maximumUnits(int[][] boxTypes, int truckSize) &#123; // sort boxTypes based on num of units per box Arrays.sort(boxTypes, (int[] a, int[] b) -&gt; b[1] - a[1]); int remaining = truckSize; int total = 0; for (int i = 0; i &lt; boxTypes.length; i++) &#123; if (remaining &lt;= 0) return total; total += Math.min(remaining, boxTypes[i][0]) * boxTypes[i][1]; remaining -= boxTypes[i][0]; &#125; return total; &#125;&#125; Find Winner on a Tic Tac Toe Game https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public String tictactoe(int[][] moves) &#123; int[][] board = new int[3][3]; for (int i = 0; i &lt; moves.length; i++) &#123; int num = 1; // first player if (i % 2 == 0) &#123; num = -1; &#125; board[moves[i][0]][moves[i][1]] = num; &#125; // check rows for (int i = 0; i &lt; 3; i++) &#123; int num = board[i][0]; if (num == 0) continue; boolean win = true; for (int j = 1; j &lt; 3; j++) &#123; if (board[i][j] != num) &#123; win = false; break; &#125; &#125; if (win) &#123; return num == -1 ? &quot;A&quot; : &quot;B&quot;; &#125; &#125; // check cols for (int i = 0; i &lt; 3; i++) &#123; int num = board[0][i]; if (num == 0) continue; boolean win = true; for (int j = 1; j &lt; 3; j++) &#123; if (board[j][i] != num) &#123; win = false; break; &#125; &#125; if (win) &#123; return num == -1 ? &quot;A&quot; : &quot;B&quot;; &#125; &#125; // check diagonal if (board[1][1] != 0 &amp;&amp;((board[0][0] == board[1][1] &amp;&amp; board[1][1] == board[2][2]) || (board[0][2] == board[1][1] &amp;&amp; board[1][1] == board[2][0]))) &#123; return board[1][1] == -1 ? &quot;A&quot; : &quot;B&quot;; &#125; if (moves.length &lt; 9) &#123; return &quot;Pending&quot;; &#125; return &quot;Draw&quot;; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123; public String tictactoe(int[][] moves) &#123; // n stands for the size of the board, n = 3 for the current game. int n = 3; // Use rows and cols to record the value on each row and each column. // diag1 and diag2 to record value on diagonal or anti-diagonal. int[] rows = new int[n], cols = new int[n]; int diag = 0, anti_diag = 0; // Two players having value of 1 and -1, player_1 with value = 1 places first. int player = 1; for (int[] move : moves)&#123; // Get the row number and column number for this move. int row = move[0], col = move[1]; // Update the row value and column value. rows[row] += player; cols[col] += player; // If this move is placed on diagonal or anti-diagonal, // we shall update the relative value as well. if (row == col)&#123; diag += player; &#125; if (row + col == n - 1)&#123; anti_diag += player; &#125; // Check if this move meets any of the winning conditions. if (Math.abs(rows[row]) == n || Math.abs(cols[col]) == n || Math.abs(diag) == n || Math.abs(anti_diag) == n)&#123; return player == 1 ? &quot;A&quot; : &quot;B&quot;; &#125; // If no one wins so far, change to the other player alternatively. // That is from 1 to -1, from -1 to 1. player *= -1; &#125; // If all moves are completed and there is still no result, we shall check if // the grid is full or not. If so, the game ends with draw, otherwise pending. return moves.length == n * n ? &quot;Draw&quot; : &quot;Pending&quot;; &#125;&#125; Sum of Subarray Minimums https://leetcode.com/problems/sum-of-subarray-minimums/ Solutions count the contributions of each element being the smallest element 1234567891011121314151617181920class Solution &#123; public int sumSubarrayMins(int[] arr) &#123; int l = arr.length; if (l == 0) return 0; Stack&lt;Integer&gt; s = new Stack(); long res = 0; s.add(0); int mod = (int)(Math.pow(10, 9) + 7); for (int i = 1; i &lt;= l; i++) &#123; while (!s.isEmpty() &amp;&amp; arr[s.peek()] &gt; (i == l? 0 : arr[i])) &#123; int j = s.pop(); int k = s.isEmpty() ? -1 :s.peek(); res += (long)arr[j] * (j - k) * (i - j); res = res % mod; &#125; s.push(i); &#125; return (int)res; &#125;&#125; Minimum Swaps to Group All 1’s Together https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/ Solutions sliding window O(n) time, O(1) space prefix sum: O(n) time, O(n) space 1234567891011121314151617181920class Solution &#123; public int minSwaps(int[] data) &#123; int ones = Arrays.stream(data).sum(); int cnt_one = 0, max_one = 0; int left = 0, right = 0; while (right &lt; data.length) &#123; // updating the number of 1&#x27;s by adding the new element cnt_one += data[right++]; // maintain the length of the window to ones if (right - left &gt; ones) &#123; // updating the number of 1&#x27;s by removing the oldest element cnt_one -= data[left++]; &#125; // record the maximum number of 1&#x27;s in the window max_one = Math.max(max_one, cnt_one); &#125; return ones - max_one; &#125;&#125; My attempt123456789101112131415161718192021222324class Solution &#123; public int minSwaps(int[] data) &#123; int l = data.length; int[] sum = new int[l]; sum[0] = data[0]; for (int i = 1; i &lt; l; i++) &#123; sum[i] = data[i] + sum[i - 1]; &#125; if (sum[l - 1] &lt; 2 || sum[l - 1] == l) &#123; return 0; &#125; int min = Integer.MAX_VALUE; for (int i = 0; i &lt;= l - sum[l - 1]; i++) &#123; int lastIndex = i + sum[l-1] - 1; int localMin = sum[l - 1] - sum[lastIndex] + sum[i]; if (data[i] == 1) &#123; localMin--; &#125; min = Math.min(localMin, min); &#125; return min; &#125;&#125; Maximum Length of Subarray With Positive Product https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/ Solutions record the first negative number’s index(my solution) dry run My solution1234567891011121314151617181920212223242526272829class Solution &#123; public int getMaxLen(int[] nums) &#123; int negatives = 0; int max = 0; int count = 0; int firstNegative = -1; for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == 0) &#123; negatives = 0; count = 0; firstNegative = -1; continue; &#125; if (nums[i] &lt; 0) &#123; if (firstNegative == -1) &#123; firstNegative = i; &#125; negatives++; &#125; if (negatives % 2 == 1 &amp;&amp; firstNegative != -1) &#123; // but there&#x27;s odd number of negatives, count between first negative and current max = Math.max(max, i - firstNegative); &#125; else if (negatives % 2 == 0) &#123; max = Math.max(max, count + 1); &#125; count++; &#125; return max; &#125;&#125; dry runlink1234567891011121314151617181920212223class Solution &#123; public int getMaxLen(int[] nums) &#123; int positive = 0, negative = 0; // length of positive and negative results int ans = 0; for(int x : nums) &#123; if(x == 0) &#123; positive = 0; negative = 0; &#125; else if(x &gt; 0) &#123; positive++; negative = negative == 0 ? 0 : negative+1; &#125; else &#123; int temp = positive; positive = negative == 0 ? 0 : negative+1; negative = temp+1; &#125; ans = Math.max(ans, positive); &#125; return ans; &#125;&#125; Nested List Weight Sum https://leetcode.com/problems/nested-list-weight-sum/ solutions DFS BFS Coding tricks12Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;NestedInteger&gt;(nestedList);queue.addAll(ni.getList()); Lowest Common Ancestor with parent pointer https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/ Solutions S1. Set S2. traverse both paths Set Solution1234567891011121314class Solution &#123; public Node lowestCommonAncestor(Node p, Node q) &#123; HashSet&lt;Integer&gt; set = new HashSet(); while (p != null) &#123; set.add(p.val); p = p.parent; &#125; while (q != null) &#123; if (set.contains(q.val)) return q; q = q.parent; &#125; return q; &#125;&#125; travers both paths solution1234567891011class Solution &#123; public Node lowestCommonAncestor(Node p, Node q) &#123; Node n1 = p; Node n2 = q; while (n1 != n2) &#123; n1 = n1.parent == null ? q : n1.parent; n2 = n2.parent == null ? p : n2.parent; &#125; return n1; &#125;&#125; Smallest Common Region https://leetcode.com/problems/smallest-common-region/ Solutions use a tree structure to record the parent of each node(my method) use a hashMap to record the parent 12345678910111213141516171819202122232425262728293031323334353637383940class Node &#123; //List&lt;Node&gt; children = new ArrayList&lt;Node&gt;(); String val = &quot;&quot;; public Node(String val) &#123; this.val = val; &#125; Node parent = null;&#125;class Solution &#123; public String findSmallestRegion(List&lt;List&lt;String&gt;&gt; regions, String region1, String region2) &#123; // thoughts: create a tree struction and a set of all tree nodes, then find the lowest common ancestor. HashMap&lt;String, Node&gt; map = new HashMap(); // create a tree auto of the regions. for (List&lt;String&gt; region: regions) &#123; Node parentNode = map.getOrDefault(region.get(0), new Node(region.get(0))); map.put(region.get(0), parentNode); for (int i = 1; i &lt; region.size(); i++) &#123; Node child = map.getOrDefault(region.get(i), new Node(region.get(i))); map.put(region.get(i), child); //parentNode.children.add(child); child.parent = parentNode; &#125; &#125; // find the lowest common ancestor Node n1 = map.get(region1); Node n2 = map.get(region2); HashSet&lt;String&gt; paths = new HashSet(); while (n1 != null) &#123; paths.add(n1.val); n1 = n1.parent; &#125; while (n2 != null) &#123; if (paths.contains(n2.val)) return n2.val; n2 = n2.parent; &#125; return &quot;&quot;; &#125;&#125; 12345678910111213141516171819202122class Solution &#123; public String findSmallestRegion(List&lt;List&lt;String&gt;&gt; regions, String region1, String region2) &#123; HashMap&lt;String, String&gt; map = new HashMap(); for (List&lt;String&gt; region: regions) &#123; for (int i = 1; i &lt; region.size(); i++) &#123; map.put(region.get(i), region.get(0)); &#125; &#125; // find the lowest common ancestor HashSet&lt;String&gt; paths = new HashSet(); while (region1 != null) &#123; paths.add(region1); region1 = map.get(region1); &#125; while (region2 != null) &#123; if (paths.contains(region2)) return region2; region2 = map.get(region2); &#125; return &quot;&quot;; &#125;&#125; without set123456789101112Map&lt;String, String&gt; parent = new HashMap&lt;&gt;();for(List&lt;String&gt; rs: regions) &#123; for(int j = 1; j &lt; rs.size(); j++) &#123; parent.put(rs.get(j), rs.get(0)); &#125;&#125;String p1 = region1, p2 = region2;while(!p1.equals(p2)) &#123; p1 = parent.getOrDefault(p1, region2); p2 = parent.getOrDefault(p2, region1);&#125;return p1; Cinema seat allocation https://leetcode.com/problems/cinema-seat-allocation/submissions/ Solutions only iterate reserved rows S1. use a boolean array for each row S2. use a set for each row S2. use an integer for the row, use bitwise operations 1.51234567891011121314151617181920212223242526272829class Solution &#123; public int maxNumberOfFamilies(int n, int[][] reservedSeats) &#123; HashMap&lt;Integer, boolean[]&gt; reservedRows = new HashMap(); for (int[] seat: reservedSeats) &#123; boolean[] cols = reservedRows.getOrDefault(seat[0] - 1, new boolean[10]); cols[seat[1] - 1] = true; reservedRows.put(seat[0] - 1, cols); &#125; //System.out.println(reservedRows.size()); int result = 2 * (n - reservedRows.size()); for (boolean[] cols : reservedRows.values()) &#123; if (!cols[1] &amp;&amp; !cols[2] &amp;&amp; !cols[3] &amp;&amp; !cols[4]) &#123; cols[3] = true; cols[4] = true; result++; &#125; if (!cols[3] &amp;&amp; !cols[4] &amp;&amp; !cols[5] &amp;&amp; !cols[6]) &#123; cols[5] = true; cols[6] = true; result++; &#125; if (!cols[5] &amp;&amp; !cols[6] &amp;&amp; !cols[7] &amp;&amp; !cols[8]) &#123; result++; &#125; &#125; return result; &#125;&#125; S21234567891011121314151617181920212223242526272829class Solution &#123; public int maxNumberOfFamilies(int n, int[][] reservedSeats) &#123; HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; reservedRows = new HashMap(); for (int[] seat: reservedSeats) &#123; HashSet&lt;Integer&gt; cols = reservedRows.getOrDefault(seat[0] - 1, new HashSet&lt;Integer&gt;()); cols.add(seat[1] - 1); reservedRows.put(seat[0] - 1, cols); &#125; //System.out.println(reservedRows.size()); int result = 2 * (n - reservedRows.size()); for (HashSet&lt;Integer&gt; cols : reservedRows.values()) &#123; if (!cols.contains(1) &amp;&amp; !cols.contains(2) &amp;&amp; !cols.contains(3) &amp;&amp; !cols.contains(4)) &#123; cols.add(3); cols.add(4); result++; &#125; if (!cols.contains(3) &amp;&amp; !cols.contains(4) &amp;&amp; !cols.contains(5) &amp;&amp; !cols.contains(6)) &#123; cols.add(5); cols.add(6); result++; &#125; if (!cols.contains(5) &amp;&amp; !cols.contains(6) &amp;&amp; !cols.contains(7) &amp;&amp; !cols.contains(8)) &#123; result++; &#125; &#125; return result; &#125;&#125; S312345678910111213141516171819202122232425class Solution &#123; public int maxNumberOfFamilies(int n, int[][] reservedSeats) &#123; HashMap&lt;Integer, Integer&gt; reservedRows = new HashMap(); for (int[] seat: reservedSeats) &#123; reservedRows.put(seat[0], reservedRows.getOrDefault(seat[0], 0) | (1 &lt;&lt; seat[1])); &#125; int result = 2 * (n - reservedRows.size()); for (int cols : reservedRows.values()) &#123; boolean reserved = false; if ((cols &amp; 60) == 0) &#123; reserved = true; result++; &#125; if ((cols &amp; 960) == 0) &#123; reserved = true; result++; &#125; if (!reserved &amp;&amp; (cols &amp; 240) == 0) &#123; result++; &#125; &#125; return result; &#125;&#125; Distribute Coins in Binary Tree https://leetcode.com/problems/distribute-coins-in-binary-tree/ Solutions divide and conquer, only look at two layers (parent, left, right) return excess number of coins up each level, as it levels, it increase the total answer record answer on each level. overall way of thinking, bottom up solution, move excess number as soon as we find it. 1234567891011121314class Solution &#123; private int ans; public int distributeCoins(TreeNode root) &#123; dfs(root); return ans; &#125; private int dfs(TreeNode root) &#123; if (root == null) return 0; int l = dfs(root.left); int r = dfs(root.right); ans += Math.abs(l) + Math.abs(r); return root.val + l + r - 1; &#125;&#125; Roblox Design Browser History https://leetcode.com/problems/design-browser-history/ Solutions two stacks trick, while loop two conditions (steps &gt; 0 &amp;&amp; back.size() &gt; 1) doubly linked list (trickier to write) 1234567891011121314151617181920212223242526272829303132333435class BrowserHistory &#123; Stack&lt;String&gt; back; Stack&lt;String&gt; forward; public BrowserHistory(String homepage) &#123; back = new Stack(); forward = new Stack(); back.add(homepage); &#125; public void visit(String url) &#123; forward.clear(); back.add(url); &#125; public String back(int steps) &#123; String page = &quot;&quot;; while (steps &gt; 0 &amp;&amp; back.size() &gt; 1) &#123; page = back.pop(); forward.add(page); steps--; &#125; return back.peek(); &#125; public String forward(int steps) &#123; String page = &quot;&quot;; while(steps &gt; 0 &amp;&amp; !forward.isEmpty()) &#123; page = forward.pop(); back.add(page); steps--; &#125; return back.peek(); &#125;&#125; Text Justification https://leetcode.com/problems/text-justification/ Solutions Single Responsibility Principle (split into smaller functions) It’s a special case when there’s only one word in the row last row is different too, because it needs to split into two parts, one appending 1 space, one append all the rest of the spaces my own solution1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123; if (words.length == 0) return new ArrayList&lt;String&gt;(); List&lt;String&gt; res = new ArrayList&lt;String&gt;(); int left = 0, right = 0, wordCharLength = 0; while (right &lt; words.length) &#123; int wordLength = words[right].length(); int rowLengthWithSpaces = wordCharLength + (right - left) - 1; // if previous range plus current word exceeds max width, justify the previous range, and reset the range start if (rowLengthWithSpaces + 1 + wordLength &gt; maxWidth) &#123; res.add(justify(words, left, right - 1, wordCharLength, maxWidth - rowLengthWithSpaces + (right - left) - 1, maxWidth)); left = right; wordCharLength = 0; &#125; right = right + 1; wordCharLength += wordLength; &#125; // add last range to the solution res.add(lastRowConverting(words, left, words.length - 1, maxWidth)); return res; &#125; // converting last row includes two parts, // 1. everything before the last word should be concatinate with 1 space // 2. last word should be treated using a normal justify function with a shorter maxWidth private String lastRowConverting(String[] words, int left, int right, int maxWidth) &#123; StringBuilder lastRow = new StringBuilder(); // if there&#x27;s more than one word, // 1. append these words with a space to the answer, // 2. maxWidth decrease by the size of the word + space while (left &lt; right) &#123; lastRow.append(words[left] + &quot; &quot;); maxWidth -= (words[left].length() + 1); left++; &#125; int lastWordLength = words[right].length(); // justify last word lastRow.append(justify(words, left, right, lastWordLength, maxWidth - lastWordLength, maxWidth)); return lastRow.toString(); &#125; private String justify(String[] words, int left, int right, int charLength, int totalSpaces, int maxWidth) &#123; // space slots int slots = right - left; // if there&#x27;s no slots, that means it&#x27;s one word, so each spacePerSlot should be totalSpace int spacePerSlot = slots == 0 ? totalSpaces : totalSpaces / slots; // only valid if there&#x27;s more than one slots int spaceDiff = slots == 0 ? 0 : totalSpaces % slots; StringBuilder sb = new StringBuilder(); while (left &lt;= right) &#123; sb.append(words[left]); // if there&#x27;s more than one slot, don&#x27;t append space to the last word int spacesAfterThisWord = (slots != 0 &amp;&amp; left == right) ? 0 : spacePerSlot + (spaceDiff &gt; 0 ? 1 : 0); for (int j = 0; j &lt; spacesAfterThisWord;j++) &#123; sb.append(&quot; &quot;); &#125; left++; spaceDiff--; &#125; return sb.toString(); &#125;&#125; Word Search https://leetcode.com/problems/word-search/ Solutions use existing board instead of extra space, mark visited cell &quot;#&quot; check if there’s char that’s not in the board check if the word’s length is longer than total num of chars check 4 directions at each cell. 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public boolean exist(char[][] board, String word) &#123; int m = board.length; int n = board[0].length; if (word.length() &gt; m * n) return false; HashSet&lt;Character&gt; set = new HashSet(); for (char[] cs : board) for (char c : cs) set.add(c); for (char c : word.toCharArray()) if (!set.contains(c)) return false; //actual traverse for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (board[i][j] == word.charAt(0)) &#123; boolean res = dfs(board, word, 0, i, j); if (res) return true; &#125; &#125; &#125; return false; &#125; private boolean dfs(char[][] board, String word, int idx, int i, int j) &#123; int m = board.length; int n = board[0].length; if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || board[i][j] != word.charAt(idx)) return false; if (idx == word.length() - 1) return true; board[i][j] = &#x27;#&#x27;; boolean up = dfs(board, word, idx + 1, i - 1, j); boolean down = dfs(board, word, idx + 1, i + 1, j); boolean left = dfs(board, word, idx + 1, i, j - 1); boolean right = dfs(board, word, idx + 1, i, j + 1); board[i][j] = word.charAt(idx); return up || down || left || right; &#125;&#125; 4/28/2022 Course Schedule II https://leetcode.com/problems/course-schedule-ii/ solutions Topological sort methods dfs with colors (permanent, temporary, and empty), add permanent node only. start with each empty node, and mark each one gray, top down, if a gray is met again, that means there’s a cycle. indegree, indegree means how many parents/dependencies one node has, only add node whose indegree is 0, that means all the dependencies are process already. decrease each node’s indegrees by one when a different node unlocks this node indegrees1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int[] findOrder(int numCourses, int[][] prerequisites) &#123; int[] indegrees = new int[numCourses]; HashMap&lt;Integer, List&lt;Integer&gt;&gt; unlocks = new HashMap(); for (int[] pre : prerequisites) &#123; indegrees[pre[0]]++; List&lt;Integer&gt; unlock = unlocks.getOrDefault(pre[1], new ArrayList&lt;Integer&gt;()); unlock.add(pre[0]); unlocks.put(pre[1], unlock); &#125; Queue&lt;Integer&gt; q = new LinkedList(); int[] ans = new int[numCourses]; int k = 0; for (int i = 0; i &lt; numCourses; i++) &#123; if (indegrees[i] == 0) &#123; // this is very smart, because all the ones that don&#x27;t have dependencies are added to the queue as well. q.add(i); &#125; &#125; //System.out.println(unlocks); while (!q.isEmpty()) &#123; int size = q.size(); for (int i = 0; i &lt; size; i++) &#123; int cur = q.poll(); ans[k++] = cur; if (unlocks.containsKey(cur)) &#123; List&lt;Integer&gt; unlock = unlocks.get(cur); for (int dependency : unlock) &#123; if (--indegrees[dependency] == 0) &#123; q.add(dependency); &#125; &#125; &#125; &#125; &#125; if (k == numCourses) &#123; return ans; &#125; return new int[0]; &#125;&#125; Number of Matching Subsequences https://leetcode.com/problems/number-of-matching-subsequences/submissions/ Solutions binary search (my solution) record all indice for all chars in s for each word’s character, check if there exists an char that’s behind the previous char’s index go through each word in parallel (m being the length of s, n being the length of words) brute force O(mn), TLE for each char in s, create a HashMap or array[26], optimised, O(m + num of chars of all words) &lt; O(mn), because m * n - (m + n * l) = mn - m - nl = m(n-1) - nl ~= n(m-l), as long as m is bigger than l, this method is more efficient, which is true. otherwise, most of words longer than l can be eliminated by checking the length diff between l and m in O(1) for each word my binary solution (my solution)1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int numMatchingSubseq(String s, String[] words) &#123; HashMap&lt;Character, List&lt;Integer&gt;&gt; map = new HashMap(); for (int i = 0; i &lt; s.length(); i++) &#123; List&lt;Integer&gt; l = map.getOrDefault(s.charAt(i), new ArrayList&lt;Integer&gt;()); l.add(i); map.put(s.charAt(i), l); &#125; int ans = 0; for (String word : words) &#123; int idx = -1; int i = 0; for (; i &lt; word.length(); i++) &#123; if (!map.containsKey(word.charAt(i))) break; idx = findIndexToTheRightOf(idx, map.get(word.charAt(i))); //System.out.println(word.charAt(i) + &quot;: &quot; + idx); if (idx == -1) break; &#125; if (i == word.length()) ans++; &#125; return ans; &#125; private int findIndexToTheRightOf(int idx, List&lt;Integer&gt; list) &#123; if (list.size() == 0 || list.get(list.size() - 1) &lt;= idx) return -1; int left = 0, right = list.size() - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (list.get(mid) &lt;= idx) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return list.get(left) &gt; idx ? list.get(left) : list.get(right); &#125;&#125; parallel with all indices (my solution)123456789101112131415161718192021222324252627class Solution &#123; public int numMatchingSubseq(String s, String[] words) &#123; int ans = 0; int[] indice = new int[words.length]; List&lt;Integer&gt;[] heads = new ArrayList[26]; for (int i = 0; i &lt; 26; i++) heads[i] = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; words.length; i++) heads[words[i].charAt(0) - &#x27;a&#x27;].add(i); for (char c: s.toCharArray()) &#123; List&lt;Integer&gt; l = heads[c - &#x27;a&#x27;]; heads[c - &#x27;a&#x27;] = new ArrayList&lt;Integer&gt;(); for (int i : l) &#123; indice[i]++; if (indice[i] == words[i].length()) &#123; ans++; &#125; else if (indice[i] &lt; words[i].length()) &#123; char ch = words[i].charAt(indice[i]); heads[ch - &#x27;a&#x27;].add(i); &#125; &#125; &#125; return ans; &#125;&#125; parallel OOP (given solution)12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int numMatchingSubseq(String S, String[] words) &#123; int ans = 0; ArrayList&lt;Node&gt;[] heads = new ArrayList[26]; for (int i = 0; i &lt; 26; ++i) heads[i] = new ArrayList&lt;Node&gt;(); for (String word: words) heads[word.charAt(0) - &#x27;a&#x27;].add(new Node(word, 0)); for (char c: S.toCharArray()) &#123; ArrayList&lt;Node&gt; old_bucket = heads[c - &#x27;a&#x27;]; heads[c - &#x27;a&#x27;] = new ArrayList&lt;Node&gt;(); for (Node node: old_bucket) &#123; node.index++; if (node.index == node.word.length()) &#123; ans++; &#125; else &#123; heads[node.word.charAt(node.index) - &#x27;a&#x27;].add(node); &#125; &#125; old_bucket.clear(); &#125; return ans; &#125;&#125;class Node &#123; String word; int index; public Node(String w, int i) &#123; word = w; index = i; &#125;&#125;","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"}]},{"title":"Trie","slug":"Trie","date":"2022-04-03T03:31:32.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/04/03/Trie/","link":"","permalink":"https://deyikong.github.io/2022/04/03/Trie/","excerpt":"","text":"##Search Suggestion System: https://leetcode.com/problems/search-suggestions-system/ link12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// Custom class Trie with function to get 3 words starting with given prefixclass Trie &#123; // Node definition of a trie class Node &#123; boolean isWord = false; List&lt;Node&gt; children = Arrays.asList(new Node[26]); &#125;; Node Root, curr; List&lt;String&gt; resultBuffer; // Runs a DFS on trie starting with given prefix and adds all the words in the resultBuffer, limiting result size to 3 void dfsWithPrefix(Node curr, String word) &#123; if (resultBuffer.size() == 3) return; if (curr.isWord) resultBuffer.add(word); // Run DFS on all possible paths. for (char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c++) if (curr.children.get(c - &#x27;a&#x27;) != null) dfsWithPrefix(curr.children.get(c - &#x27;a&#x27;), word + c); &#125; Trie() &#123; Root = new Node(); &#125; // Inserts the string in trie. void insert(String s) &#123; // Points curr to the root of trie. curr = Root; for (char c : s.toCharArray()) &#123; if (curr.children.get(c - &#x27;a&#x27;) == null) curr.children.set(c - &#x27;a&#x27;, new Node()); curr = curr.children.get(c - &#x27;a&#x27;); &#125; // Mark this node as a completed word. curr.isWord = true; &#125; List&lt;String&gt; getWordsStartingWith(String prefix) &#123; curr = Root; resultBuffer = new ArrayList&lt;String&gt;(); // Move curr to the end of prefix in its trie representation. for (char c : prefix.toCharArray()) &#123; if (curr.children.get(c - &#x27;a&#x27;) == null) return resultBuffer; curr = curr.children.get(c - &#x27;a&#x27;); &#125; dfsWithPrefix(curr, prefix); return resultBuffer; &#125;&#125;;class Solution &#123; List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123; Trie trie = new Trie(); List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); // Add all words to trie. for (String w : products) trie.insert(w); String prefix = new String(); for (char c : searchWord.toCharArray()) &#123; prefix += c; result.add(trie.getWordsStartingWith(prefix)); &#125; return result; &#125;&#125;;","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"trie","slug":"trie","permalink":"https://deyikong.github.io/tags/trie/"}]},{"title":"Binary Search Tree","slug":"Binary-Search-Tree","date":"2022-03-18T06:48:05.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/18/Binary-Search-Tree/","link":"","permalink":"https://deyikong.github.io/2022/03/18/Binary-Search-Tree/","excerpt":"","text":"Binary Search Tree Keys pre order traverse in order traverse -&gt; sorted array post order traverse Searching Recursive 123456TREE-SEARCH(x, k) if x == NIL or k == x.key return x if x &lt; x.key return TREE-SEARCH(x.left, k) else return TREE-SEARCH(x.right, k) Iterative 123456ITERATIVE-TREE-SEARCH(x, k) while x != NIL or k != x.key if k &lt; x.key x = x.left else x = x.right return x minimum and maximum 1234TREE-MINIMUM(x) while x != NIL AND x.left != NIL x = x.left return x 1234TREE-MAXIMUM(x) while x != NIL AND x.right != NIL x = x.right return x successor and predecessor Successor 12345678910TREE-SUCCESSOR(x) // if this node has a right subtree, just return the minimum in the right subtree if x!= NIL AND x.right != NIL return TREE_MINIMUM(x) // if this node doesn&#x27;t have a right subtree, go up and find the first parent that&#x27;s the left child of its parent y = x.parent while y != NIL AND y.right = x x = y y = y.plarent return y predecessor 12345678910TREE-PREDECESSOR(x) // if this node has a left subtree, just return the maximum in the left subtree if x!= NIL AND x.left != NIL return TREE_MINIMUM(x) // if this node doesn&#x27;t have a left subtree, go up and find the first parent that&#x27;s the right child of its parent y = x.parent while y != NIL AND y.left = x x = y y = y.plarent return y ####insertion The key point is to find the NIL location, keep the parent, and then append it to the parent loop invariant: p is always the parent of x maintain p is the parent of x termination: x is NIL 12345678910111213TREE-INSERT(T, z) p = NIL x = T.root while x != NIL p = x.parent if z.key &gt; x.key x = x.right else x = x.left if p = NIL T.root = z // Tree is empty elseif z.key &gt; p.key p.right = z else p.left = z","categories":[],"tags":[]},{"title":"Sum","slug":"Sum","date":"2022-03-06T07:40:41.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/06/Sum/","link":"","permalink":"https://deyikong.github.io/2022/03/06/Sum/","excerpt":"","text":"Two Sum Keys: HashMap O(n) https://leetcode.com/problems/two-sum/ Two Sum II (not allow duplicates) (sorted) Keys: two pointer O(nlog(n)) https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ Three Sum (not allow duplicates) (sorted or not) Keys: two pointer outer loop to traverse first occurence hashset no-sort O(n^2) https://leetcode.com/problems/3sum/ Three Sum Smaller https://leetcode.com/problems/3sum-smaller/ (To be reviewed) Three Sum Closest https://leetcode.com/problems/3sum-closest/ (To be reviewed) Four Sum https://leetcode.com/problems/4sum/","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"sum","slug":"sum","permalink":"https://deyikong.github.io/tags/sum/"}]},{"title":"Binary Search","slug":"Binary-Search","date":"2022-03-06T04:19:39.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/06/Binary-Search/","link":"","permalink":"https://deyikong.github.io/2022/03/06/Binary-Search/","excerpt":"","text":"Concepts Key get rid of a side that’s not what we are looking for whether you can git rid of the border depending on if the border might be the final answer use the smallest sample size(size = 1) to test if the condition allows entering the while loop, and test if the condition allows exiting the loop Questions closet to a target number(stop at two elements) kth closet to a target number find the closest, then traverse left or right find the first occurrence of a number 1,2,2,2 find 2; stop at two elements don’t stop at the target, keep moving the left: l = m, not m - 1 because can’t get rid of m sorted array of unknown size double the range to find the end index first then try to find it in the found range maximum profit in job scheduling(hard): https://leetcode.com/problems/maximum-profit-in-job-scheduling/ dp + binary search. top down + bottom up.","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"https://deyikong.github.io/tags/algorithm/"},{"name":"interview","slug":"interview","permalink":"https://deyikong.github.io/tags/interview/"},{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"binary search","slug":"binary-search","permalink":"https://deyikong.github.io/tags/binary-search/"}]},{"title":"Fundamental","slug":"Fundamental","date":"2022-03-06T01:51:47.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/06/Fundamental/","link":"","permalink":"https://deyikong.github.io/2022/03/06/Fundamental/","excerpt":"","text":"list cases when it’s a complicated problem, list all the cases you can think of before coding with an example Loop Invariants Initialization: It’s true prior to the first iteration of the loop(variable initializations before the loop) Maintenance: If it’s true before an iteration of the loop, it remains true before the next iteration(logic inside the loop) Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct(condition to stop the loop) Initialization -&gt; base case, Maintenance -&gt; inductive step, Termination -&gt; Condition; Termination usually involves loop invariants. In math, inductive steps carries on infinitely, but in here, we stop the loop when the termination happens. Notes: practice always come up with the loop invariants before you start writing the loop. Running time Big O notation Worst-cast and average-case analysis Worst-Case an upper bound on teh running time for some algorithms, the worst case occurs fairly often. Like searching a database for a piece of missing data. Designing Algorithms Principles: Incremental: e.g.: insertion sort, insert single element into its proper place. Divide and conquer: recurisve is from this principle three steps: Divide into smaller subproblems Conquer the subproblems by solving them recursively Combine the solution analysis recurrence equation : running time of a recursion call. binary search","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"fundamentals","slug":"fundamentals","permalink":"https://deyikong.github.io/tags/fundamentals/"}]},{"title":"Sorting","slug":"Sorting","date":"2022-03-06T00:53:41.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/06/Sorting/","link":"","permalink":"https://deyikong.github.io/2022/03/06/Sorting/","excerpt":"","text":"Insertion Sort Keys playing card sorted part + unsorted part insert in sorted array Code array 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.*;class GFG&#123;// Function to sort an array using insertion sortstatic void insertionSort(int arr[], int n)&#123; int i, key, j; for (i = 1; i &lt; n; i++) &#123; key = arr[i]; j = i - 1; // Move elements of arr[0..i-1], // that are greater than key to // one position ahead of their // current position while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) &#123; arr[j + 1] = arr[j]; j = j - 1; &#125; arr[j + 1] = key; &#125;&#125;// Function to print an array of size Nstatic void printArray(int arr[], int n)&#123; int i; // Print the array for (i = 0; i &lt; n; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println();&#125;// Driver codepublic static void main(String[] args)&#123; int arr[] = &#123; 12, 11, 13, 5, 6 &#125;; int N = arr.length; // Function Call insertionSort(arr, N); printArray(arr, N);&#125;&#125; Singly linkedlist My solution (not optimal, hard to remember) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; //base case: if (head == null) return head; // loop invariants: // for each i in [0, n], list before head[i] is sorted, after is not sorted. // initialization: i = 1, becasue head[0] is already sorted by itself // maintenance: as i++, we need to insert head[i] into it&#x27;s right place. // temination condition: when it passes all the elements ListNode local = head.next; int localTraverseCount = 1; ListNode localPrev = head; ListNode headCopy = head; while(local != null) &#123; // break current node localPrev.next = local.next; ListNode next = local.next; // if it&#x27;s the smallest if (local.val &lt; headCopy.val) &#123; local.next = headCopy; headCopy = local; &#125; else &#123; // loop through the first part to insert the node ListNode insertTraverse = headCopy; int insertTraverseCount = 1; //local invariants: insertTraverse.val is smaller than local.val but insertTraverse.next.val is bigger while (insertTraverseCount &lt; localTraverseCount &amp;&amp; insertTraverse.val &lt; local.val &amp;&amp; insertTraverse.next.val &lt; local.val) &#123; insertTraverse = insertTraverse.next; insertTraverseCount++; &#125; // termination: it&#x27;s own place, or found a node whose .next.val is bigger // insert local after insertTraverse ListNode temp = insertTraverse.next; insertTraverse.next = local; local.next = temp; if (insertTraverseCount == localTraverseCount) &#123; localPrev = local; &#125; &#125; localTraverseCount++; local = next; &#125; return headCopy; &#125;&#125; given solutions: 123456789101112131415161718192021222324public ListNode insertionSortList(ListNode head) &#123; ListNode dummy = new ListNode(); ListNode curr = head; while (curr != null) &#123; // At each iteration, we insert an element into the resulting list. ListNode prev = dummy; // find the position to insert the current node while (prev.next != null &amp;&amp; prev.next.val &lt; curr.val) &#123; prev = prev.next; &#125; ListNode next = curr.next; // insert the current node to the new list curr.next = prev.next; prev.next = curr; // moving on to the next iteration curr = next; &#125; return dummy.next;&#125; https://leetcode.com/problems/insertion-sort-list/ Selection Sort Keys for for loop swap(i, minSoFar) Examples sort an array with two stacks sort an array with one stack Code selection sort 12345678910111213141516171819202122232425262728293031323334353637383940// Selection sort in Javaimport java.util.Arrays;class SelectionSort &#123; void selectionSort(int array[]) &#123; int size = array.length; for (int step = 0; step &lt; size - 1; step++) &#123; int min_idx = step; for (int i = step + 1; i &lt; size; i++) &#123; // To sort in descending order, change &gt; to &lt; in this line. // Select the minimum element in each loop. if (array[i] &lt; array[min_idx]) &#123; min_idx = i; &#125; &#125; // put min at the correct position swap(array, min_idx, step); &#125; &#125; void swap(array, x, y) &#123; int temp = array[x]; array[x] = array[y]; array[y] = temp; &#125; // driver code public static void main(String args[]) &#123; int[] data = &#123; 20, 12, 10, 15, 2 &#125;; SelectionSort ss = new SelectionSort(); ss.selectionSort(data); System.out.println(&quot;Sorted Array in Ascending Order: &quot;); System.out.println(Arrays.toString(data)); &#125;&#125; stacks 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// Java program to sort an// array using stackimport java.io.*;import java.util.*;class GFG&#123; // This function return the sorted stack static Stack&lt;Integer&gt; sortStack(Stack&lt;Integer&gt; input) &#123; Stack&lt;Integer&gt; tmpStack = new Stack&lt;Integer&gt;(); while (!input.empty()) &#123; // pop out the first element int tmp = input.peek(); input.pop(); // while temporary stack is not empty and top of stack is smaller than temp while (!tmpStack.empty() &amp;&amp; tmpStack.peek() &lt; tmp) &#123; // pop from temporary stack and push it to the input stack input.push(tmpStack.peek()); tmpStack.pop(); &#125; // push tmp in temporary of stack tmpStack.push(tmp); &#125; return tmpStack; &#125; static void sortArrayUsingStacks(int []arr, int n) &#123; // push array elements // to stack Stack&lt;Integer&gt; input = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) input.push(arr[i]); // Sort the temporary stack Stack&lt;Integer&gt; tmpStack = sortStack(input); // Put stack elements in arr[] for (int i = 0; i &lt; n; i++) &#123; arr[i] = tmpStack.peek(); tmpStack.pop(); &#125; &#125; // Driver Code public static void main(String args[]) &#123; int []arr = &#123;10, 5, 15, 45&#125;; int n = arr.length; sortArrayUsingStacks(arr, n); for (int i = 0; i &lt; n; i++) System.out.print(arr[i] + &quot; &quot;); &#125;&#125; https://www.geeksforgeeks.org/sorting-array-using-stacks/ Merge Sort Keys Divide and conquer Divide, Conquer, Combine Psudo code 123456789MergeSort(A, p, r)if p &lt; r q = [p + r] / 2 MergeSort(A, p, q) MergeSort(A, q + 1, r) Merge(A, p, q, r)Merge(A, p, q, r) Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/* Java program for Merge Sort */class MergeSort&#123; // Merges two subarrays of arr[]. // First subarray is arr[l..m] // Second subarray is arr[m+1..r] void merge(int arr[], int l, int m, int r) &#123; // Find sizes of two subarrays to be merged int n1 = m - l + 1; int n2 = r - m; /* Create temp arrays */ int L[] = new int[n1]; int R[] = new int[n2]; /*Copy data to temp arrays*/ for (int i = 0; i &lt; n1; ++i) L[i] = arr[l + i]; for (int j = 0; j &lt; n2; ++j) R[j] = arr[m + 1 + j]; /* Merge the temp arrays */ // Initial indexes of first and second subarrays int i = 0, j = 0; // Initial index of merged subarray array int k = l; while (i &lt; n1 &amp;&amp; j &lt; n2) &#123; if (L[i] &lt;= R[j]) &#123; arr[k] = L[i]; i++; &#125; else &#123; arr[k] = R[j]; j++; &#125; k++; &#125; /* Copy remaining elements of L[] if any */ while (i &lt; n1) &#123; arr[k] = L[i]; i++; k++; &#125; /* Copy remaining elements of R[] if any */ while (j &lt; n2) &#123; arr[k] = R[j]; j++; k++; &#125; &#125; // Main function that sorts arr[l..r] using // merge() void sort(int arr[], int l, int r) &#123; if (l &lt; r) &#123; // Find the middle point int m =l+ (r-l)/2; // Sort first and second halves sort(arr, l, m); sort(arr, m + 1, r); // Merge the sorted halves merge(arr, l, m, r); &#125; &#125; /* A utility function to print array of size n */ static void printArray(int arr[]) &#123; int n = arr.length; for (int i = 0; i &lt; n; ++i) System.out.print(arr[i] + &quot; &quot;); System.out.println(); &#125; // Driver code public static void main(String args[]) &#123; int arr[] = &#123; 12, 11, 13, 5, 6, 7 &#125;; System.out.println(&quot;Given Array&quot;); printArray(arr); MergeSort ob = new MergeSort(); ob.sort(arr, 0, arr.length - 1); System.out.println(&quot;\\nSorted array&quot;); printArray(arr); &#125;&#125; https://www.geeksforgeeks.org/merge-sort/ Merge Two sorted arrays, in place. Keys: principle: three pointers in order not to override, it’s best to move from right to left. so the condition need to check which bigger instead of who’s smaller my first thought was moving all the elements of nums1 to the end and go from left. it works too, but there’s more to write. how to write the condition is worth memorizing 1234567891011121314151617public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int p = m - 1; int q = n - 1; for (int i = m + n - 1; i &gt;= 0; i--) &#123; // positive condition: when will we need to // swap with nums1 // 1. when nums1 still has elements and nums2 is out // 2. when nums1 still has elements and nums1[p] &gt; nums2[q] // notes: it&#x27;s &quot;&gt;&quot; because we go from right to left. if (p &gt;= 0 &amp;&amp; (q &lt; 0 || (nums1[p] &gt; nums2[q]))) &#123; nums1[i] = nums1[p--]; continue; &#125; nums1[i] = nums2[q--]; &#125;&#125; https://leetcode.com/problems/merge-sorted-array/ Heapsort Keys: heapify the whole array keep swapping with the largest element Can be used to implement a priority queue Time Complexity: O(nlog(n)) Quick Sort Psudo Psudo 12345678910111213141516171819202122232425262728293031323334PARTITION(A, p, r) x = A[r] i = p - 1 for j = p to r - 1 if (A[j] &lt;= x) i = i + 1 swap(A[i], A[j]) swap(A[r], A[i+1]) return i+1;//--------Normal quicksort--------QUICKSORT(A, p, r) if p &lt; r q = PARTATION(A, p, r) QUICKSORT(A, p, q -1) QUICKSORT(A, q + 1, r) //--------Tail quicksort--------TAIL-RECURSIVE-QUICKSORT(A, p, r) while(p &lt; r) q = PARTITION(A, p, r) TAIL-RECURSIVE-QUICKSORT(A, p, q - 1) p = q + 1//--------Tail quicksort with logn most depth:sub-call on the smaller half--------TAIL-RECURSIVE-QUICKSORT(A, p, r) while(p &lt; r) q = PARTITION(A, p, r) if (p - q &gt; r - p) TAIL-RECURSIVE-QUICKSORT(A, p, q - 1) p = q + 1 else TAIL-RECURSIVE-QUICKSORT(A, q + 1, r) r = q - 1 Sorting related problems Merge Intervals https://leetcode.com/problems/merge-intervals/ Keys: sort the array based on the first value, then use a stack to linear scan back. My attempt 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; public int[][] merge(int[][] intervals) &#123; // sort intervals based on the start time // quick sort it quicksort(intervals, 0, intervals.length - 1); for(int[] interval : intervals) &#123; System.out.println(interval[0] + &quot; &quot; + interval[1]); &#125; Stack&lt;int[]&gt; stack = new Stack(); for (int[] interval: intervals) &#123; if (stack.isEmpty() || interval[0] &gt; stack.peek()[1]) &#123; stack.push(interval); &#125; else &#123; stack.peek()[1] = Math.max(interval[1],stack.peek()[1]); &#125; &#125; int[][] ret = new int[stack.size()][2]; int i = stack.size() - 1; while(!stack.isEmpty()) &#123; ret[i--] = stack.pop(); &#125; return ret; &#125; private void quicksort(int[][] intervals, int q, int r) &#123; while (q &lt; r) &#123; int p = partition(intervals, q, r); if (q - p &lt; r - p) &#123; quicksort(intervals, q, p - 1); q = p + 1; &#125; else &#123; quicksort(intervals, p + 1, r); r = p - 1; &#125; &#125; &#125; private int partition(int[][] intervals, int q, int r) &#123; int[] pi = intervals[r]; int i = q - 1; for (int j = q; j &lt; r; j++) &#123; if (intervals[j][0] &lt;= pi[0]) &#123; i++; swap(intervals, i, j); &#125; &#125; swap(intervals, i + 1, r); return i + 1; &#125; private void swap(int[][] intervals, int i, int j) &#123; int[] temp = intervals[i]; intervals[i] = intervals[j]; intervals[j] = temp; &#125;&#125;","categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"sorting","slug":"sorting","permalink":"https://deyikong.github.io/tags/sorting/"}]},{"title":"Start My Algorithm Journey","slug":"start","date":"2022-03-05T23:12:14.000Z","updated":"2023-02-14T07:34:04.820Z","comments":true,"path":"2022/03/05/start/","link":"","permalink":"https://deyikong.github.io/2022/03/05/start/","excerpt":"","text":"今天开始准备刷题，学习算法。 这个blog用来记录我的历程。","categories":[],"tags":[]}],"categories":[{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/categories/algorithms/"}],"tags":[{"name":"interview","slug":"interview","permalink":"https://deyikong.github.io/tags/interview/"},{"name":"technical","slug":"technical","permalink":"https://deyikong.github.io/tags/technical/"},{"name":"leetcode","slug":"leetcode","permalink":"https://deyikong.github.io/tags/leetcode/"},{"name":"OOP","slug":"OOP","permalink":"https://deyikong.github.io/tags/OOP/"},{"name":"algorithms","slug":"algorithms","permalink":"https://deyikong.github.io/tags/algorithms/"},{"name":"kth biggest","slug":"kth-biggest","permalink":"https://deyikong.github.io/tags/kth-biggest/"},{"name":"trie","slug":"trie","permalink":"https://deyikong.github.io/tags/trie/"},{"name":"sum","slug":"sum","permalink":"https://deyikong.github.io/tags/sum/"},{"name":"algorithm","slug":"algorithm","permalink":"https://deyikong.github.io/tags/algorithm/"},{"name":"binary search","slug":"binary-search","permalink":"https://deyikong.github.io/tags/binary-search/"},{"name":"fundamentals","slug":"fundamentals","permalink":"https://deyikong.github.io/tags/fundamentals/"},{"name":"sorting","slug":"sorting","permalink":"https://deyikong.github.io/tags/sorting/"}]}