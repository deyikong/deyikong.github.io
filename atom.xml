<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deyi Kong</title>
  
  <subtitle>My personal website</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-28T01:26:39.527Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Deyi Kong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thoughts on OOD</title>
    <link href="http://example.com/2022/04/28/Thoughts-on-OOP/"/>
    <id>http://example.com/2022/04/28/Thoughts-on-OOP/</id>
    <published>2022-04-28T01:13:43.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-to-approach-OOP-interview-questions">How to approach OOP interview questions</h2><p>I was at a friend’s place three days ago, and we were talking uncertain OOP technical interviews are.</p><p>Then we sat down and went through an OOP problem and conclude the following three steps to offer ideas to approach OOP interviews.</p><ol><li>outline (bottom up): write all the classes/components from small scope to big scope</li><li>implementation (top down): write all method signatures from big scope to small scope.</li></ol><ul><li>for the biggest class, start with the constructor, properties and then methods from the requirements(use cases, properties).</li><li>for the smaller classes, requirements are from their upper classes’ implementation details + initial requirements(use cases, properties).</li></ul><ol start="3"><li>changes (bottom up): if there’s any structural changes(deletion, addition, modification) on a particular part of the code, trace all places that used these changed part bottom up.</li></ol><p>Overall programming habit, BFS: don’t program too deep when there’s a thought, just go down 1 step down and just write the signature and keep writing.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;How-to-approach-OOP-interview-questions&quot;&gt;How to approach OOP interview questions&lt;/h2&gt;
&lt;p&gt;I was at a friend’s place three days ago, a</summary>
      
    
    
    
    
    <category term="OOP" scheme="http://example.com/tags/OOP/"/>
    
    <category term="interview" scheme="http://example.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Kth Biggest</title>
    <link href="http://example.com/2022/04/21/Kth-Biggest/"/>
    <id>http://example.com/2022/04/21/Kth-Biggest/</id>
    <published>2022-04-21T02:13:31.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kth-Largest-Element-in-an-Array">Kth Largest Element in an Array</h2><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">https://leetcode.com/problems/kth-largest-element-in-an-array/</a></p><h3 id="Solutions-5">Solutions</h3><ul><li>sort</li><li>max heap</li><li>min heap</li><li>quick select</li></ul><pre><div class="caption"><span>min heap</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;((a, b) -&gt; a - b);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;            pq.add(nums[i]);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> pq.peek();             <span class="hljs-keyword">if</span> (nums[i] &gt; top) &#123;                pq.poll();                pq.add(nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span> pq.peek();    &#125;&#125;</code></pre><pre><div class="caption"><span>quickselect</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = nums.length - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(nums, start, end);             <span class="hljs-keyword">if</span> (p == k - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">return</span> nums[p];            &#125;            <span class="hljs-keyword">if</span> (p &gt; k - <span class="hljs-number">1</span>) &#123;                end = p - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">if</span> (p &lt; k - <span class="hljs-number">1</span>) &#123;                start = p + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;        <span class="hljs-keyword">if</span> (s == e) <span class="hljs-keyword">return</span> s;        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> nums[e];        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> s - <span class="hljs-number">1</span>, j = s;        <span class="hljs-comment">//loop invariant, left of i is all smaller than p, including i. between i and j are all bigger than p</span>        <span class="hljs-keyword">while</span> (j &lt; e) &#123;           <span class="hljs-keyword">if</span> (nums[j] &gt; p) &#123;               i++;               swap(nums, i, j);           &#125;            j++;        &#125;        swap(nums, i+<span class="hljs-number">1</span>, e);        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];        nums[i] = nums[j];        nums[j] = temp;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Kth-Largest-Element-in-an-Array&quot;&gt;Kth Largest Element in an Array&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/kth-largest-element-</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Bucket Sort</title>
    <link href="http://example.com/2022/04/12/Bucket-Sort-And-Meeting-Rooms/"/>
    <id>http://example.com/2022/04/12/Bucket-Sort-And-Meeting-Rooms/</id>
    <published>2022-04-12T05:05:41.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Range-Addition">Range Addition</h2><p><a href="https://leetcode.com/problems/range-addition/">https://leetcode.com/problems/range-addition/</a></p><h3 id="Solutions">Solutions</h3><ul><li>S1. normal O(n * k)</li><li>S2. only update start and end+1 to get an array of difference,  O(n + k),<ul><li>how to come up with this thought:<ul><li>loop order from left to right, order plays a key part</li><li>record the difference</li></ul></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getModifiedArray(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span>[][] updates) &#123;       <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[length];         <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> updates.length;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; l; i++) &#123;            res[updates[i][<span class="hljs-number">0</span>]] += updates[i][<span class="hljs-number">2</span>];            <span class="hljs-keyword">if</span> (updates[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &lt; length) &#123;                res[updates[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>] -= updates[i][<span class="hljs-number">2</span>];            &#125;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; length; i++) &#123;            res[i] = res[i - <span class="hljs-number">1</span>] + res[i];        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;</code></pre><h2 id="Similar-problem-as-above-Car-Pooling">Similar problem as above, Car Pooling</h2><p><a href="https://leetcode.com/problems/car-pooling/">https://leetcode.com/problems/car-pooling/</a></p><h3 id="Solutions-2">Solutions</h3><ul><li>bucket sort</li><li>timestamp, TreeMap</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">carPooling</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] trips, <span class="hljs-type">int</span> capacity)</span> &#123;        <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1000</span>];                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; trips.length; i++) &#123;            <span class="hljs-keyword">if</span> (trips[i][<span class="hljs-number">0</span>] &gt; capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            res[trips[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] += trips[i][<span class="hljs-number">0</span>];            res[trips[i][<span class="hljs-number">2</span>] - <span class="hljs-number">1</span>] -= trips[i][<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; res.length; i++) &#123;            res[i] = res[i - <span class="hljs-number">1</span>] + res[i];            <span class="hljs-keyword">if</span> (res[i] &gt; capacity) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">carPooling</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] trips, <span class="hljs-type">int</span> capacity)</span> &#123;                Map&lt;Integer, Integer&gt; timestamps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; trips.length; i++) &#123;            <span class="hljs-keyword">if</span> (trips[i][<span class="hljs-number">0</span>] &gt; capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            timestamps.put(trips[i][<span class="hljs-number">1</span>], timestamps.getOrDefault(trips[i][<span class="hljs-number">1</span>], <span class="hljs-number">0</span>) + trips[i][<span class="hljs-number">0</span>]);            timestamps.put(trips[i][<span class="hljs-number">2</span>], timestamps.getOrDefault(trips[i][<span class="hljs-number">2</span>], <span class="hljs-number">0</span>) - trips[i][<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">usedCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> change : timestamps.values()) &#123;            usedCapacity += change;            <span class="hljs-keyword">if</span> (usedCapacity &gt; capacity) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="Corporate-Flight-Booking">Corporate Flight Booking</h2><p><a href="https://leetcode.com/problems/corporate-flight-bookings/">https://leetcode.com/problems/corporate-flight-bookings/</a></p><h2 id="Solutions-3">Solutions</h2><ul><li>same as above</li></ul><h2 id="Meeting-Room-II">Meeting Room II</h2><p><a href="https://leetcode.com/problems/meeting-rooms-ii/">https://leetcode.com/problems/meeting-rooms-ii/</a></p><h3 id="Solutions-4">Solutions</h3><ul><li>TreeMap</li><li>PriorityQueue</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;        Map&lt;Integer, Integer&gt; timestamps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>();                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval: intervals) &#123;            timestamps.put(interval[<span class="hljs-number">0</span>], timestamps.getOrDefault(interval[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);            timestamps.put(interval[<span class="hljs-number">1</span>], timestamps.getOrDefault(interval[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> timestamp : timestamps.values()) &#123;           last += timestamp;            max = Math.max(max, last);        &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minMeetingRooms</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals)</span> &#123;                <span class="hljs-comment">// base case, if there&#x27;s no intervals, return 0</span>        <span class="hljs-keyword">if</span> (intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-comment">// min heap</span>        PriorityQueue&lt;Integer&gt; allocator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Integer&gt;(            intervals.length,            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer a, Integer b)</span> &#123;                    <span class="hljs-keyword">return</span> a - b;                &#125;            &#125;        );                <span class="hljs-comment">//Sort the intervals by start time</span>        Arrays.sort(            intervals,            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;                <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span> &#123;                    <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];                &#125;            &#125;        );                <span class="hljs-comment">// add the first meeting</span>        allocator.add(intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]);                <span class="hljs-comment">//Interate over remaining intervals</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; intervals.length; i++) &#123;                        <span class="hljs-comment">// If the earliest room is free, assign this room to this meeting</span>            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= allocator.peek()) &#123;                allocator.poll();            &#125;            <span class="hljs-comment">//if a new room is to be assigned, add it to the heap. </span>            allocator.add(intervals[i][<span class="hljs-number">1</span>]);        &#125;                <span class="hljs-keyword">return</span> allocator.size();    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Range-Addition&quot;&gt;Range Addition&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/range-addition/&quot;&gt;https://leetcode.com/problems/range-a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Problems</title>
    <link href="http://example.com/2022/04/05/Problems/"/>
    <id>http://example.com/2022/04/05/Problems/</id>
    <published>2022-04-05T16:32:04.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h1>04/05/2022</h1><h2 id="Longest-Common-Prefix">Longest Common Prefix</h2><p><a href="https://leetcode.com/problems/longest-common-prefix/">https://leetcode.com/problems/longest-common-prefix/</a></p><h3 id="Solutions-6">Solutions:</h3><ul><li>horizontal scanning(from left to right)</li><li>vertical scanning(compare the ith char on all the elements each time)</li><li>divide and conquer</li><li>Binary search</li></ul><h3 id="Follow-up">Follow up</h3><p>LCP called multiple times frequently</p><ul><li>use a trie<ul><li>node path must only have one child element</li><li>stop at the “isWord” node</li><li>must match the character</li></ul></li></ul><h2 id="Letter-Combinations-of-a-phone-number">Letter Combinations of a phone number</h2><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">https://leetcode.com/problems/letter-combinations-of-a-phone-number/</a></p><h3 id="Solutions-7">Solutions:</h3><ul><li>backtracking</li><li>DFS</li></ul><h2 id="Remove-Nth-Node-From-End-of-List">Remove Nth Node From End of List</h2><p><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">https://leetcode.com/problems/remove-nth-node-from-end-of-list/</a></p><h3 id="Solutions-8">Solutions</h3><ul><li>two pass, one to find the length, the other to find the first Node.</li></ul><h2 id="Generate-Parentheses">Generate Parentheses</h2><p><a href="https://leetcode.com/problems/generate-parentheses/">https://leetcode.com/problems/generate-parentheses/</a></p><ul><li>DFS(permutation: only allow certain paths when conditions met)</li><li>Closure Number:  (To be reviewed)</li></ul><h2 id="swap-nodes-in-pairs">swap nodes in pairs</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">https://leetcode.com/problems/swap-nodes-in-pairs/</a></p><ul><li>set up loop invariant and keep them. prev, first, second.</li></ul><h2 id="remove-element">remove element</h2><p><a href="https://leetcode.com/problems/remove-element/">https://leetcode.com/problems/remove-element/</a></p><h3 id="Solutions-9">Solutions</h3><ul><li>two pointer, slow fast pointer. copy over all the not equal elements</li><li>two pointer, opposite direction, reduce right pointer by one when equal.</li></ul><h2 id="implement-strstr">implement strstr</h2><p><a href="https://leetcode.com/problems/implement-strstr/">https://leetcode.com/problems/implement-strstr/</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strStr</span><span class="hljs-params">(String haystack, String needle)</span> &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-type">char</span>[] hays = haystack.toCharArray();        <span class="hljs-type">char</span>[] needles = needle.toCharArray();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; i &lt; hays.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span> (j &lt; needles.length &amp;&amp; i+j &lt; hays.length &amp;&amp; hays[i+j] == needles[j]) &#123;               j++;             &#125;            <span class="hljs-keyword">if</span> (j == needles.length) &#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><h2 id="Find-First-and-Last-Position-of-Element-in-Sorted-Array">Find First and Last Position of Element in Sorted Array</h2><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><h3 id="solutions">solutions</h3><ul><li>binary search two ends. stop at two elements, because we might get into a dead loop.</li></ul><h2 id="Count-and-Say">Count and Say</h2><p><a href="https://leetcode.com/problems/count-and-say/">https://leetcode.com/problems/count-and-say/</a></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;     <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;     &#125;           <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;          prev = convert(prev);      &#125;      <span class="hljs-keyword">return</span> prev;  &#125;  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(String prev)</span> &#123;      <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();      <span class="hljs-type">char</span>[] chars = prev.toCharArray();      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;          <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> chars[i];          <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                    <span class="hljs-keyword">while</span> (i+<span class="hljs-number">1</span> &lt; chars.length &amp;&amp; chars[i+<span class="hljs-number">1</span>] == c) &#123;             count++;               i++;          &#125;           sb.append(count);          sb.append(c);      &#125;      <span class="hljs-keyword">return</span> sb.toString();  &#125;</code></pre><h2 id="Combination-Sum">Combination Sum</h2><p><a href="https://leetcode.com/problems/combination-sum/">https://leetcode.com/problems/combination-sum/</a></p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();        <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;        combine(candidates, <span class="hljs-number">0</span>, target, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">combine</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> level, <span class="hljs-type">int</span> target, List&lt;Integer&gt; list)</span> &#123;        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;            res.add(list);            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">if</span> (level == candidates.length) &#123;            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(count * candidates[level] &lt;= target) &#123;            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;                copy.add(candidates[level]);            &#125;            combine(candidates, level + <span class="hljs-number">1</span>, target - count * candidates[level], copy);            count++;        &#125;    &#125;&#125;</code></pre><h2 id="Jump-game-II">Jump game II</h2><p><a href="https://leetcode.com/problems/jump-game-ii/">https://leetcode.com/problems/jump-game-ii/</a></p><h3 id="Solutions-10">Solutions</h3><ul><li>dp N^2</li><li>BFS, N</li><li>greedy</li></ul><h1>04/06/2022</h1><h2 id="Permutations">Permutations</h2><p><a href="https://leetcode.com/problems/permutations/">https://leetcode.com/problems/permutations/</a></p><h3 id="Solutions-11">Solutions</h3><ul><li>key point: fill each spot with available elements</li><li>dps</li><li>swap swap</li></ul><h2 id="Combination-Sum-II">Combination Sum II</h2><p><a href="https://leetcode.com/problems/combination-sum-ii/">https://leetcode.com/problems/combination-sum-ii/</a></p><h3 id="Solutions-12">Solutions</h3><ul><li>think of each element can only show up on a level repeated times</li></ul><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">combinationSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> Arrays.stream(candidates).sum();    <span class="hljs-keyword">if</span> (target &gt; sum) &#123;        <span class="hljs-keyword">return</span> res;    &#125;    Arrays.sort(candidates);    dps(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());     <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> idx, List&lt;Integer&gt; list)</span> &#123;    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;        res.add(list);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span> (idx &gt;= candidates.length) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> <span class="hljs-variable">nextUnique</span> <span class="hljs-operator">=</span> idx + <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (nextUnique &lt; candidates.length &amp;&amp; candidates[nextUnique] == candidates[idx]) &#123;       nextUnique++;         count++;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= count; i++) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">rem</span> <span class="hljs-operator">=</span> target - i * candidates[idx];        <span class="hljs-keyword">if</span> (rem &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;        List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list);         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;            copy.add(candidates[idx]);        &#125;        dps(candidates, rem, nextUnique, copy);    &#125;&#125;</code></pre><h2 id="Permutations-II-with-duplicated-elements">Permutations II (with duplicated elements)</h2><p><a href="https://leetcode.com/problems/permutations-ii/">https://leetcode.com/problems/permutations-ii/</a></p><h3 id="Solutions-13">Solutions</h3><ul><li>sort array</li><li>use a set to check on each level to see if the element was added already</li></ul><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permuteUnique</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;    Arrays.sort(nums);    permute(nums, <span class="hljs-number">0</span>);    <span class="hljs-keyword">return</span> res;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> idx)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;   <span class="hljs-keyword">if</span> (idx == n) &#123;       List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;           list.add(nums[i]);       &#125;       res.add(list);       <span class="hljs-keyword">return</span>;   &#125;     HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();    <span class="hljs-comment">// not adding current </span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> idx; k &lt; n; k++) &#123;        <span class="hljs-keyword">if</span> (set.contains(nums[k])) &#123;           <span class="hljs-keyword">continue</span>;         &#125;           swap(nums, idx, k);            permute(nums, idx + <span class="hljs-number">1</span>);           swap(nums, idx, k);         set.add(nums[k]);    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];    nums[j] = nums[i];    nums[i] = temp;&#125;</code></pre><h2 id="Power-x-n">Power(x, n)</h2><p><a href="https://leetcode.com/problems/powx-n/">https://leetcode.com/problems/powx-n/</a></p><h3 id="Solutions-14">Solutions</h3><ul><li>cut in half each time, dp to remember half.</li><li>check negative and odd situation</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;       <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / helper(x, -n);       &#125;       <span class="hljs-keyword">return</span> helper(x, n);   &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;       <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;           <span class="hljs-keyword">return</span> x;       &#125;       <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n / <span class="hljs-number">2</span>;       <span class="hljs-type">double</span> <span class="hljs-variable">halfValue</span> <span class="hljs-operator">=</span> helper(x, half);       <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> n % <span class="hljs-number">2</span>;       <span class="hljs-keyword">if</span> (mod != <span class="hljs-number">0</span>) &#123;          <span class="hljs-keyword">return</span> halfValue * halfValue * x;        &#125;       <span class="hljs-keyword">return</span> halfValue * halfValue;   &#125;</code></pre><h2 id="Spiral-Matrix">Spiral Matrix</h2><p><a href="https://leetcode.com/problems/spiral-matrix/">https://leetcode.com/problems/spiral-matrix/</a></p><h3 id="Solutions-15">Solutions</h3><ul><li>separate directions</li><li>check boundary</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">spiralOrder</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;       List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();       <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> matrix.length;       <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;       <span class="hljs-type">int</span> <span class="hljs-variable">layers</span> <span class="hljs-operator">=</span> (Math.min(row, col) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; layers; i++) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">innerRow</span> <span class="hljs-operator">=</span> row - <span class="hljs-number">2</span> * i;           <span class="hljs-type">int</span> <span class="hljs-variable">innerCol</span> <span class="hljs-operator">=</span> col - <span class="hljs-number">2</span> * i;           <span class="hljs-keyword">if</span> (innerCol == <span class="hljs-number">1</span>) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerRow; j++) &#123;                   res.add(matrix[i + j][i]);               &#125;               <span class="hljs-keyword">return</span> res;           &#125;           <span class="hljs-keyword">if</span> (innerRow == <span class="hljs-number">1</span>) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerCol; j++) &#123;                   res.add(matrix[i][i + j]);               &#125;               <span class="hljs-keyword">return</span> res;           &#125;           <span class="hljs-comment">// print top line</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerCol - <span class="hljs-number">1</span>; j++) &#123;               res.add(matrix[i][i + j]);           &#125;           <span class="hljs-comment">// print right line</span>           <span class="hljs-keyword">if</span> (col - i - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerRow - <span class="hljs-number">1</span>; j++) &#123;                   res.add(matrix[i + j][col - i -<span class="hljs-number">1</span>]);               &#125;           &#125;           <span class="hljs-comment">// print bottom line</span>           <span class="hljs-keyword">if</span> (row - i - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerCol - <span class="hljs-number">1</span>; j++) &#123;                   res.add(matrix[row - i - <span class="hljs-number">1</span>][col - i - <span class="hljs-number">1</span> - j]);               &#125;           &#125;           <span class="hljs-comment">// print left line</span>           <span class="hljs-keyword">if</span> (i &lt; col) &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; innerRow - <span class="hljs-number">1</span>; j++) &#123;                   res.add(matrix[row - i - <span class="hljs-number">1</span> - j][i]);               &#125;           &#125;       &#125;       <span class="hljs-keyword">return</span> res;   &#125;</code></pre><h2 id="Jump-Game">Jump Game</h2><p><a href="https://leetcode.com/problems/jump-game/">https://leetcode.com/problems/jump-game/</a></p><h3 id="Solutions-16">Solutions</h3><ul><li>go from left to right</li><li>remember last reachable element</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;      <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;     <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;          <span class="hljs-keyword">if</span> (i &gt; last) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;          <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> nums[i] + i;          <span class="hljs-keyword">if</span> (next &gt;= n - <span class="hljs-number">1</span>) &#123;              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;          &#125;          last = Math.max(next, last);      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  &#125;</code></pre><h2 id="Spiral-Matrix-II-fill-out-a-matrix-spirally">Spiral Matrix II (fill out a matrix spirally )</h2><p><a href="https://leetcode.com/problems/spiral-matrix-ii/">https://leetcode.com/problems/spiral-matrix-ii/</a></p><h3 id="Solutions-17">Solutions</h3><ul><li>different directions</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] generateMatrix(<span class="hljs-type">int</span> n) &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> n * n;       <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">layers</span> <span class="hljs-operator">=</span> (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;       <span class="hljs-type">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n][n];              <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; layers; i++) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">2</span> * i;           <span class="hljs-keyword">if</span> (l == <span class="hljs-number">1</span>) &#123;               res[i][i] = count;           &#125;           <span class="hljs-comment">// top</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; l - <span class="hljs-number">1</span>; j++) &#123;               res[i][i + j] = count++;           &#125;           <span class="hljs-comment">// right</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; l - <span class="hljs-number">1</span>; j++) &#123;               res[i + j][n - i - <span class="hljs-number">1</span>] = count++;           &#125;           <span class="hljs-comment">// bottom</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; l - <span class="hljs-number">1</span>; j++) &#123;               res[n - i - <span class="hljs-number">1</span>][n - i - <span class="hljs-number">1</span> - j] = count++;           &#125;           <span class="hljs-comment">// left</span>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; l - <span class="hljs-number">1</span>; j++) &#123;               res[n - i - <span class="hljs-number">1</span> - j][i] = count++;           &#125;       &#125;       <span class="hljs-keyword">return</span> res;   &#125;</code></pre><h2 id="unique-paths">unique paths</h2><p><a href="https://leetcode.com/problems/unique-paths/">https://leetcode.com/problems/unique-paths/</a></p><h3 id="Solutions-18">Solutions</h3><ul><li>dp</li><li>basic math: choose m - 1 or n - 1 from m - n - 2</li></ul><h2 id="unique-paths-II-with-obstacles">unique paths II (with obstacles)</h2><p><a href="https://leetcode.com/problems/unique-paths-ii/">https://leetcode.com/problems/unique-paths-ii/</a></p><h3 id="solutions-2">solutions</h3><ul><li>dp</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePathsWithObstacles</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] obstacleGrid)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obstacleGrid.length;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> obstacleGrid[<span class="hljs-number">0</span>].length;    <span class="hljs-keyword">if</span> (obstacleGrid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> || obstacleGrid[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (obstacleGrid[i][j] == <span class="hljs-number">1</span>) &#123;              dp[i][j] = <span class="hljs-number">0</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[i][j-<span class="hljs-number">1</span>];                 <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : dp[i - <span class="hljs-number">1</span>][j];                 dp[i][j] = left + up;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];&#125;</code></pre><h2 id="Minimum-path-sum">Minimum path sum</h2><p><a href="https://leetcode.com/problems/minimum-path-sum/">https://leetcode.com/problems/minimum-path-sum/</a></p><h3 id="Solutions-19">Solutions</h3><ul><li>dp 2D</li><li>dp 1D</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;    <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[m][n];    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;           <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j == <span class="hljs-number">0</span> ? Integer.MAX_VALUE : dp[i][j-<span class="hljs-number">1</span>];           <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> ? Integer.MAX_VALUE : dp[i - <span class="hljs-number">1</span>][j];           dp[i][j] = Math.min(left, up) + grid[i][j];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> grid.length;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid[<span class="hljs-number">0</span>].length;    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];    dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;           <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;               dp[j] = dp[j] + grid[i][j];               <span class="hljs-keyword">continue</span>;           &#125;           <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j == <span class="hljs-number">0</span> ? Integer.MAX_VALUE : dp[j - <span class="hljs-number">1</span>];           <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> i == <span class="hljs-number">0</span> ? Integer.MAX_VALUE : dp[j];           dp[j] = Math.min(left, up) + grid[i][j];        &#125;    &#125;    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];&#125;</code></pre><h2 id="Set-Matrix-Zeros">Set Matrix Zeros</h2><p><a href="https://leetcode.com/problems/set-matrix-zeroes/">https://leetcode.com/problems/set-matrix-zeroes/</a></p><h3 id="solutions-3">solutions</h3><ul><li>use two sets</li><li>use first column and first row as marker</li></ul><h2 id="search-a-2d-matrix">search a 2d matrix</h2><p><a href="https://leetcode.com/problems/search-a-2d-matrix/">https://leetcode.com/problems/search-a-2d-matrix/</a></p><h3 id="Solutions-20">Solutions</h3><ul><li>get row and col like: mid / n; mid % n;</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">searchMatrix</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix, <span class="hljs-type">int</span> target)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> matrix.length;    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length;        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, r = m * n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l)/<span class="hljs-number">2</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> mid / n;        <span class="hljs-type">int</span> <span class="hljs-variable">col</span> <span class="hljs-operator">=</span> mid % n;        <span class="hljs-keyword">if</span> (matrix[row][col] == target) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span> (matrix[row][col] &gt; target) &#123;            r = mid - <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            l = mid + <span class="hljs-number">1</span>;         &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><h1>04/07/2022</h1><h2 id="Sort-color">Sort color</h2><p><a href="https://leetcode.com/problems/sort-colors/">https://leetcode.com/problems/sort-colors/</a></p><h3 id="Solutions-21">Solutions</h3><ul><li>quicksort O(NlogN) (more general)</li><li>O(N), one pass solution<br>loop invariants:<br>three pointers, left i and right j, and cur</li><li>left elements of i are all zeros</li><li>right elements of j are all twos</li><li>elements between i and j  are all ones including i and j (this is not needed)</li></ul><p>initialization: start at cur = 0, i = 0, j = nums.length -1;<br>maintenance:</p><ul><li>if nums[cur] = 0, move it to the left of i, so swap with i and then move i to the right, then move cur to the right by one too.</li><li>if nums[cur] = 2, move it to the right of j, so swap with j and then move j to the left.</li><li>if nums[cur] = 1, ignore i or j, move cur to the right by one.<br>termination: cur &gt; j</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = nums.length -<span class="hljs-number">1</span>, cur = <span class="hljs-number">0</span>;       <span class="hljs-keyword">while</span> (cur &lt;= j) &#123;          <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">2</span>) &#123;              swap(nums, cur, j);              j--;              <span class="hljs-keyword">continue</span>;          &#125;          <span class="hljs-keyword">if</span> (nums[cur] == <span class="hljs-number">0</span>) &#123;              swap(nums, cur, i);              i++;              cur++;              <span class="hljs-keyword">continue</span>;          &#125;          cur++;      &#125;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[i];      nums[i] = nums[j];      nums[j] = temp;  &#125;</code></pre><h2 id="Subsets">Subsets</h2><p><a href="https://leetcode.com/problems/subsets/">https://leetcode.com/problems/subsets/</a></p><h3 id="solutions-4">solutions</h3><ul><li>backtracking (needs review)</li><li>dps, each level with or without the current element</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;       dps(nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());         <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> idx, List&lt;Integer&gt; list)</span> &#123;        <span class="hljs-keyword">if</span> (idx == nums.length) &#123;             res.add(list);            <span class="hljs-keyword">return</span>;        &#125;                List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list);         dps(nums, idx + <span class="hljs-number">1</span>, copy);                List&lt;Integer&gt; copy2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list);         copy2.add(nums[idx]);        dps(nums, idx + <span class="hljs-number">1</span>, copy2);    &#125;&#125;</code></pre><h2 id="Word-search">Word search</h2><p><a href="https://leetcode.com/problems/word-search/">https://leetcode.com/problems/word-search/</a></p><h3 id="solutions-5">solutions</h3><ul><li>mark visited grid ‘#’ and then change it back after dps</li><li>pruning before dps would save time:<ul><li>check if word’s length is longer than total number of elements in grid</li><li>check if there’s any element that’s not in the grid</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (word.length() &gt; m * n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;         HashSet&lt;Character&gt; uniqueChars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                uniqueChars.add(board[i][j]);            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;            <span class="hljs-keyword">if</span> (!uniqueChars.contains(word.charAt(i))) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123;                    <span class="hljs-type">boolean</span> <span class="hljs-variable">exist</span> <span class="hljs-operator">=</span> checkWord(board, i, j, word, <span class="hljs-number">0</span>);                    <span class="hljs-keyword">if</span> (exist) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, String word, <span class="hljs-type">int</span> idx)</span> &#123;        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= board.length || j &gt;= board[<span class="hljs-number">0</span>].length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(idx))&#123;               <span class="hljs-keyword">if</span> (idx == word.length() - <span class="hljs-number">1</span>) &#123;                   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;                board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;               <span class="hljs-type">boolean</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> checkWord(board, i - <span class="hljs-number">1</span>, j, word, idx + <span class="hljs-number">1</span>);               <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span>  checkWord(board, i, j - <span class="hljs-number">1</span>, word, idx + <span class="hljs-number">1</span>);               <span class="hljs-type">boolean</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span>  checkWord(board, i + <span class="hljs-number">1</span>, j, word, idx + <span class="hljs-number">1</span>);               <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> checkWord(board, i, j + <span class="hljs-number">1</span>, word, idx + <span class="hljs-number">1</span>);               board[i][j] = word.charAt(idx);               <span class="hljs-keyword">return</span> up || left || down || right;                           &#125;         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="Remove-duplicates-from-sorted-array-II">Remove duplicates from sorted array II</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/</a></p><h3 id="Solutions-22">Solutions</h3><ul><li>copy the last two elements of its kind instead of the first two because it might be overriden.</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (; j &lt; nums.length; j++) &#123;           <span class="hljs-keyword">if</span> (j + <span class="hljs-number">2</span> &gt;=  nums.length || nums[j] != nums[j + <span class="hljs-number">2</span>]) &#123;               nums[i] = nums[j];               i++;           &#125;         &#125;        <span class="hljs-keyword">return</span> i;    &#125;&#125;</code></pre><p>#04/08/2022</p><h2 id="search-in-rotated-sorted-array">search in rotated sorted array</h2><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">https://leetcode.com/problems/search-in-rotated-sorted-array/</a></p><h3 id="solutions-6">solutions</h3><ul><li>S1. find the pivot first, then binary search one of them</li><li>S2. one binary search, add more conditions to move left or right</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums.length;       <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];         <span class="hljs-keyword">if</span> (target == first) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = m - <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;            <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt; m &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;                last = mid;                <span class="hljs-keyword">break</span>;            &#125;             <span class="hljs-keyword">if</span> (nums[mid] &gt;= first)&#123;               start = mid + <span class="hljs-number">1</span>;             &#125; <span class="hljs-keyword">else</span> &#123;               end = mid - <span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-comment">// first half</span>        <span class="hljs-keyword">if</span> (target &gt; first) &#123;           <span class="hljs-keyword">return</span> binarySearch(nums, <span class="hljs-number">0</span>, last == <span class="hljs-number">0</span> ? m - <span class="hljs-number">1</span> : last, target);        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// last half</span>           <span class="hljs-keyword">return</span> binarySearch(nums, last + <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, target);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> mid;             <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                r = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left&lt;=right)        &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right-left)/<span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span>(target == nums[mid])            &#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span>(nums[mid] &lt;= nums[right])            &#123;                <span class="hljs-keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[right])                &#123;                    left = mid +<span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    right = mid -<span class="hljs-number">1</span>;                &#125;            &#125;<span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(target&lt;nums[mid]&amp;&amp;target&gt;=nums[left])&#123;                    right = mid - <span class="hljs-number">1</span>;                &#125;<span class="hljs-keyword">else</span>&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="Search-in-Rotated-Sorted-Array-II">Search in Rotated Sorted Array II</h2><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">https://leetcode.com/problems/search-in-rotated-sorted-array-ii/</a></p><h3 id="Solutions-23">Solutions</h3><ul><li>same as the first one except when trying to locate pivot, check which side the pivot it located in by checking to the right or left</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums.length;       <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];         <span class="hljs-keyword">if</span> (target == first) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, end = m - <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (start &lt;= end) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> start + (end - start) / <span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span> (mid + <span class="hljs-number">1</span> &lt; m &amp;&amp; nums[mid] &gt; nums[mid + <span class="hljs-number">1</span>]) &#123;                last = mid;                <span class="hljs-keyword">break</span>;            &#125;             <span class="hljs-keyword">if</span> (nums[mid] == first) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>;                <span class="hljs-keyword">while</span>(count &lt; m &amp;&amp; nums[count] == nums[mid]) &#123;                    count++;                &#125;                <span class="hljs-keyword">if</span> (count == m) &#123;                   end = mid - <span class="hljs-number">1</span>;                 &#125; <span class="hljs-keyword">else</span> &#123;                   start = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; first)&#123;               start = mid + <span class="hljs-number">1</span>;             &#125; <span class="hljs-keyword">else</span> &#123;               end = mid - <span class="hljs-number">1</span>;             &#125;        &#125;        <span class="hljs-comment">// first half</span>        <span class="hljs-keyword">if</span> (target &gt; first) &#123;           <span class="hljs-keyword">return</span> binarySearch(nums, <span class="hljs-number">0</span>, last == <span class="hljs-number">0</span> ? m - <span class="hljs-number">1</span> : last, target);        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// last half</span>           <span class="hljs-keyword">return</span> binarySearch(nums, last + <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>, target);        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> target)</span> &#123;        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> l + (r - l) / <span class="hljs-number">2</span>;             <span class="hljs-keyword">if</span> (nums[mid] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;             <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;                r = mid - <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                l = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre><h2 id="Remove-Duplicates-from-Sorted-List">Remove Duplicates from Sorted List</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">https://leetcode.com/problems/remove-duplicates-from-sorted-list/</a></p><h3 id="Solutions-24">Solutions</h3><ul><li>two pointer, prev and cur</li><li>loop invariants:<ul><li>everything left to prev including prev are all unique</li><li>move cur to the right without connecting if it’s the same as prev</li></ul></li></ul><h2 id="Remove-Duplicates-from-Sorted-List-II">Remove Duplicates from Sorted List II</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution/">https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/solution/</a></p><h3 id="Solutions-25">Solutions</h3><ul><li>Sentinel head solution: dummy head, because we are not sure what’s the head, so we check which is head first, then append it to the dummy head.</li><li>loop invariants:<ul><li>everything left to last are correct answer</li><li>set last.next to the first element of its kind, and then override it if it’s not the only element of its kind</li><li>move “last” if current element is different than the last element</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;        <span class="hljs-comment">//loop invariants: cur </span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);        <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> dummy;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">// if two are the same</span>            <span class="hljs-keyword">if</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.val == cur.next.val) &#123;                <span class="hljs-comment">// skip all duplicates</span>                <span class="hljs-keyword">while</span> (cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.val == cur.next.val) &#123;                    cur = cur.next;                &#125;                last.next = cur.next;            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// two are not the same</span>                last = last.next;             &#125;             <span class="hljs-comment">// must have</span>            cur = cur.next;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre><h2 id="subsets-ii">subsets ii</h2><p><a href="https://leetcode.com/problems/subsets-ii/submissions/">https://leetcode.com/problems/subsets-ii/submissions/</a></p><h3 id="Solutions-26">Solutions</h3><ul><li>skip the dps level for the same elements. so for duplicated levels, add different number of elements there</li><li>trick: set count to 1, and loop at least 0 and 1. if ther’s more, loop extra.</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        Arrays.sort(nums);            dps(nums, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;());        <span class="hljs-keyword">return</span> res;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> idx, List&lt;Integer&gt; list)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums.length;        <span class="hljs-keyword">if</span> (idx == m) &#123;            res.add(list);            <span class="hljs-keyword">return</span>;        &#125;            <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (idx+count &lt; m &amp;&amp; nums[idx] == nums[idx + count]) &#123;            count++;        &#125;        List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(list);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= count; i++) &#123;            dps(nums, idx + count, copy);            copy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(copy);            copy.add(nums[idx]);        &#125;    &#125;&#125;</code></pre><h2 id="Reverse-LinkedList-II">Reverse LinkedList II</h2><p><a href="https://leetcode.com/problems/reverse-linked-list-ii/">https://leetcode.com/problems/reverse-linked-list-ii/</a></p><p>trick part, remember the element before the reversal, and also the element where the reversal stops.</p><h3 id="Solutions-27">Solutions</h3><ul><li>use dummy head, because we don’t know the new head ahead of time</li><li>record “newHead” and “newTail” and “before”</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;      <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();        dummy.next = head;      <span class="hljs-type">ListNode</span> <span class="hljs-variable">before</span> <span class="hljs-operator">=</span> head;       <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;         <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;           <span class="hljs-keyword">if</span> (count == left - <span class="hljs-number">1</span>) &#123;               before = cur;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == left) &#123;                <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> head;                 <span class="hljs-type">ListNode</span> <span class="hljs-variable">newTail</span> <span class="hljs-operator">=</span> head;                <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverseHead</span> <span class="hljs-operator">=</span> cur;                newTail = cur;               <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;                <span class="hljs-keyword">while</span> (count &lt;= right) &#123;                   <span class="hljs-keyword">if</span> (count == right) &#123;                     newHead = reverseHead;                          &#125;                  <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> reverseHead.next;                    reverseHead.next = prev;                   prev = reverseHead;                  count++;                   reverseHead = next;               &#125;               newTail.next = reverseHead;               <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span>) &#123;                  dummy.next = newHead;                &#125; <span class="hljs-keyword">else</span> &#123;                  before.next = newHead;                &#125;               <span class="hljs-keyword">return</span> dummy.next;           &#125;                        cur = cur.next;           count++;         &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre><h2 id="Restore-IP-Address">Restore IP Address</h2><p><a href="https://leetcode.com/problems/restore-ip-addresses/">https://leetcode.com/problems/restore-ip-addresses/</a></p><h3 id="Solutions-28">Solutions</h3><ul><li>backtrack (my prefered dps way)</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">restoreIpAddresses</span><span class="hljs-params">(String s)</span> &#123;       <span class="hljs-type">char</span>[] chars = s.toCharArray();         dps(chars, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dps</span><span class="hljs-params">(<span class="hljs-type">char</span>[] chars, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> count, String s)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> chars.length;       <span class="hljs-keyword">if</span> (count == <span class="hljs-number">4</span>) &#123;           <span class="hljs-keyword">if</span> (idx &gt;= m) <span class="hljs-keyword">return</span>;           <span class="hljs-type">int</span> <span class="hljs-variable">lastNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;           <span class="hljs-keyword">if</span> (Character.getNumericValue(chars[idx]) == <span class="hljs-number">0</span> &amp;&amp; idx != m-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;             <span class="hljs-keyword">while</span> (idx &lt; m) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">tempNum</span> <span class="hljs-operator">=</span> Character.getNumericValue(chars[idx]);                lastNumber = lastNumber * <span class="hljs-number">10</span> + tempNum;                 idx++;                <span class="hljs-keyword">if</span>(lastNumber &gt; <span class="hljs-number">255</span>) <span class="hljs-keyword">return</span>;            &#125;           res.add(s + lastNumber);            <span class="hljs-keyword">return</span>;       &#125;         <span class="hljs-keyword">if</span> (idx == m) <span class="hljs-keyword">return</span>;        <span class="hljs-comment">//if (!Character.isDigit(chars[idx])) return;</span>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Character.getNumericValue(chars[idx]);        <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) &#123;           dps(chars, ++idx, count+<span class="hljs-number">1</span>, s  + num + <span class="hljs-string">&quot;.&quot;</span>);            <span class="hljs-keyword">return</span>;        &#125;;        <span class="hljs-keyword">while</span> (idx &lt; m &amp;&amp; num &lt;= <span class="hljs-number">255</span>) &#123;           dps(chars, ++idx, count+<span class="hljs-number">1</span>, s  + num + <span class="hljs-string">&quot;.&quot;</span>);            <span class="hljs-keyword">if</span> (idx &gt;=m) <span class="hljs-keyword">return</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">tempNum</span> <span class="hljs-operator">=</span> Character.getNumericValue(chars[idx]);            num = num * <span class="hljs-number">10</span> + tempNum;         &#125;            &#125;&#125;</code></pre><h2 id="Flip-String-to-Monotone-increasing">Flip String to Monotone increasing</h2><p><a href="https://leetcode.com/problems/flip-string-to-monotone-increasing/">https://leetcode.com/problems/flip-string-to-monotone-increasing/</a></p><h2 id="Solutions-29">Solutions</h2><ul><li>s1. check how many 0s before element and how many zeros after element i using prefix sum</li><li>s2. very tricky thought process, dp thought process too<ul><li>if current element is 1<ul><li>not flip it, stays 1, so flips[i] = flips[i - 1]</li><li>flip it to 0, flips = flips[i] = previous ones + 1</li><li>get min</li></ul></li><li>if current element is 0<ul><li>not flipping it, stay 0, flips[i] = flips[i - 1]</li><li>flip it to 1, then flips[i] = flips[i - 1] + 1, because previous doesnt’ need to change.</li><li>get min</li></ul></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minFlipsMonoIncr</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">flip</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)        &#123;            <span class="hljs-keyword">if</span>(s.charAt(i)==<span class="hljs-string">&#x27;1&#x27;</span>) &#123;                one++;            &#125; <span class="hljs-keyword">else</span> &#123;                flip++;            &#125;            flip = Math.min(one,flip);        &#125;        <span class="hljs-keyword">return</span> flip;    &#125;&#125;</code></pre><h2 id="Count-Unique-Characters-of-All-Substrings-of-a-Given-String">Count Unique Characters of All Substrings of a Given String</h2><p><a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/">https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/</a></p><h3 id="Solutions-30">Solutions</h3><ul><li>S1. count contributions between last two same character: <a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/C%2B%2BJavaPython-One-pass-O(N)">https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/128952/C%2B%2BJavaPython-One-pass-O(N)</a></li><li>S2. remember lastIndex and contribution of each character: <a href="https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/129021/O(N)-Java-Solution-DP-Clear-and-easy-to-Understand">https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/discuss/129021/O(N)-Java-Solution-DP-Clear-and-easy-to-Understand</a></li></ul><h2 id="Sum-of-Subarray-Ranges">Sum of Subarray Ranges</h2><p><a href="https://leetcode.com/problems/sum-of-subarray-ranges/">https://leetcode.com/problems/sum-of-subarray-ranges/</a></p><h3 id="Solutions-31">Solutions</h3><ul><li>S1. O(n^2), for for loop</li><li>S2. O(n) (to be reviewed) <a href="https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624222/JavaC%2B%2BPython-O(n)-solution-detailed-explanation">https://leetcode.com/problems/sum-of-subarray-ranges/discuss/1624222/JavaC%2B%2BPython-O(n)-solution-detailed-explanation</a></li></ul><p>#04/10/2022</p><h2 id="LRU-Cache">LRU Cache</h2><p><a href="https://leetcode.com/problems/lru-cache/">https://leetcode.com/problems/lru-cache/</a></p><h3 id="Solutions-32">Solutions</h3><ul><li>Node has “prev” and “next” pointer so the removal is easier</li><li>Have two dummy node “head” and “tail”, change everything in between so that we don’t have check if it’s the head or tail</li><li>separate methods to smaller ones<ul><li>popHead</li><li>appendToEnd</li><li>removeNode</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;       <span class="hljs-type">int</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, val = <span class="hljs-number">0</span>;         Node next, prev;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span> <span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;            <span class="hljs-built_in">this</span>.key = key;            <span class="hljs-built_in">this</span>.val = val;        &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span> <span class="hljs-params">()</span> &#123;            <span class="hljs-built_in">this</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        &#125;    &#125;    HashMap&lt;Integer, Node&gt; map;    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    Node head, tail;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;        <span class="hljs-built_in">this</span>.capacity = capacity;       <span class="hljs-built_in">this</span>.map =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();        <span class="hljs-built_in">this</span>.tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();        head.next = tail;        tail.prev = head;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;       <span class="hljs-keyword">if</span>(!map.containsKey(key)) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;       <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);        moveNodeToEnd(node);        <span class="hljs-keyword">return</span> node.val;    &#125;           <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;        <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> map.get(key);            node.val = value;            moveNodeToEnd(node);            <span class="hljs-keyword">return</span>;        &#125;       <span class="hljs-keyword">if</span> (map.size() == capacity) removeHead();         <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(key, value);        map.put(key, node);       appendNode(node);     &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveNodeToEnd</span><span class="hljs-params">(Node node)</span> &#123;        removeNode(node);        appendNode(node);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeHead</span><span class="hljs-params">()</span> &#123;        head = head.next;         head.prev = <span class="hljs-literal">null</span>;        map.remove(head.key);        head.key = <span class="hljs-number">0</span>;        head.val = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendNode</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> tail.prev;                prev.next = node;        node.prev = prev;                tail.prev = node;        node.next = tail;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node node)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> node.prev;        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;        prev.next = next;        next.prev = prev;                node.next = <span class="hljs-literal">null</span>;        node.prev = <span class="hljs-literal">null</span>;    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><span class="hljs-comment"> * LRUCache obj = new LRUCache(capacity);</span><span class="hljs-comment"> * int param_1 = obj.get(key);</span><span class="hljs-comment"> * obj.put(key,value);</span><span class="hljs-comment"> */</span></code></pre><h2 id="Count-Binary-Substrings">Count Binary Substrings</h2><p><a href="https://leetcode.com/problems/count-binary-substrings/">https://leetcode.com/problems/count-binary-substrings/</a></p><h3 id="Solutions-33">Solutions</h3><ul><li>count ones and zeros, take min of the two consecutive groups</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countBinarySubstrings</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-keyword">if</span> (s.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;                <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; s.length(); i++) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) == s.charAt(i - <span class="hljs-number">1</span>)) &#123;                cur++;            &#125; <span class="hljs-keyword">else</span> &#123;                res += Math.min(prev, cur);                prev = cur;                cur = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> res + Math.min(prev, cur);    &#125;&#125;</code></pre><h2 id="The-kth-Factor-of-n">The kth Factor of n</h2><p><a href="https://leetcode.com/problems/the-kth-factor-of-n/">https://leetcode.com/problems/the-kth-factor-of-n/</a></p><h3 id="Solutions-34">Solutions</h3><ul><li>O(sqrt(N))</li><li>S1. remember both halves.</li><li>S2. check if the k is in the first half, only save divisors</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthFactor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        List&lt;Integer&gt; secondHalf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n;        <span class="hljs-keyword">do</span> &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> n % i;             <span class="hljs-keyword">if</span> (mod == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;                  <span class="hljs-keyword">return</span> i;                    &#125;                j = n / i;                <span class="hljs-keyword">if</span> (i != j) &#123;                  secondHalf.add(j);                  &#125;                 k--;            &#125;            i++;        &#125; <span class="hljs-keyword">while</span> (i &lt; j);        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> secondHalf.size();        <span class="hljs-keyword">if</span> (k &gt; size) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> secondHalf.get(size - k);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthFactor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        List&lt;Integer&gt; firstHalf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();        List&lt;Integer&gt; secondHalf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> n;        <span class="hljs-keyword">do</span> &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> n % i;             <span class="hljs-keyword">if</span> (mod == <span class="hljs-number">0</span>) &#123;               firstHalf.add(i);                 j = n / i;                <span class="hljs-keyword">if</span> (i != j) &#123;                    secondHalf.add(j);                &#125;            &#125;            i++;        &#125; <span class="hljs-keyword">while</span> (i &lt; j);        <span class="hljs-type">int</span> <span class="hljs-variable">size1</span> <span class="hljs-operator">=</span> firstHalf.size();        <span class="hljs-keyword">if</span> (k &lt;= size1) <span class="hljs-keyword">return</span> firstHalf.get(k - <span class="hljs-number">1</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">size2</span> <span class="hljs-operator">=</span> secondHalf.size();        <span class="hljs-keyword">if</span> (k &gt; size1 + size2) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">return</span> secondHalf.get(size2 - (k - size1));    &#125;&#125;</code></pre><h2 id="valid-palindrome-II">valid palindrome II</h2><p><a href="https://leetcode.com/problems/valid-palindrome-ii/">https://leetcode.com/problems/valid-palindrome-ii/</a></p><h3 id="Solutions-35">Solutions</h3><ul><li>try both substrings generated by deleting each of the mismatched pair</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPalindrome</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;         <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;           <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;              <span class="hljs-keyword">return</span> checkPalindrom(s, i, j-<span class="hljs-number">1</span>) || checkPalindrom(s, i+<span class="hljs-number">1</span>, j);           &#125;            i++;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPalindrom</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-keyword">while</span> (i &lt; j) &#123;            <span class="hljs-keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            i++;            j--;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre><h2 id="Maximum-Units-on-a-Truck">Maximum Units on a Truck</h2><p><a href="https://leetcode.com/problems/maximum-units-on-a-truck/">https://leetcode.com/problems/maximum-units-on-a-truck/</a></p><h3 id="Solutions-36">Solutions</h3><ul><li>sort the array and pick from the bigger box first.</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maximumUnits</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] boxTypes, <span class="hljs-type">int</span> truckSize)</span> &#123;        <span class="hljs-comment">// sort boxTypes based on num of units per box</span>        Arrays.sort(boxTypes, (<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b) -&gt; b[<span class="hljs-number">1</span>] - a[<span class="hljs-number">1</span>]);        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> truckSize;        <span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; boxTypes.length; i++) &#123;            <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> total;            total += Math.min(remaining, boxTypes[i][<span class="hljs-number">0</span>]) * boxTypes[i][<span class="hljs-number">1</span>];             remaining -= boxTypes[i][<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">return</span> total;    &#125;&#125;</code></pre><h2 id="Find-Winner-on-a-Tic-Tac-Toe-Game">Find Winner on a Tic Tac Toe Game</h2><p><a href="https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/">https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/</a></p><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tictactoe</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] moves)</span> &#123;        <span class="hljs-type">int</span>[][]  board = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; moves.length; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;            <span class="hljs-comment">// first player</span>           <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  &#123;              num = -<span class="hljs-number">1</span>;            &#125;             board[moves[i][<span class="hljs-number">0</span>]][moves[i][<span class="hljs-number">1</span>]] = num;        &#125;        <span class="hljs-comment">// check rows</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[i][<span class="hljs-number">0</span>];             <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-type">boolean</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;               <span class="hljs-keyword">if</span> (board[i][j] != num) &#123;                   win = <span class="hljs-literal">false</span>;                   <span class="hljs-keyword">break</span>;               &#125;             &#125;            <span class="hljs-keyword">if</span> (win) &#123;                <span class="hljs-type">return</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;A&quot;</span> : <span class="hljs-string">&quot;B&quot;</span>;            &#125;        &#125;        <span class="hljs-comment">// check cols</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>][i];             <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;            <span class="hljs-type">boolean</span> <span class="hljs-variable">win</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;               <span class="hljs-keyword">if</span> (board[j][i] != num) &#123;                   win = <span class="hljs-literal">false</span>;                   <span class="hljs-keyword">break</span>;               &#125;             &#125;            <span class="hljs-keyword">if</span> (win) &#123;                <span class="hljs-type">return</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span>= -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;A&quot;</span> : <span class="hljs-string">&quot;B&quot;</span>;            &#125;        &#125;        <span class="hljs-comment">// check diagonal</span>        <span class="hljs-keyword">if</span> (board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp;((board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]) || (board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] &amp;&amp; board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == board[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>]))) &#123;            <span class="hljs-keyword">return</span> board[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == -<span class="hljs-number">1</span> ? <span class="hljs-string">&quot;A&quot;</span> : <span class="hljs-string">&quot;B&quot;</span>;        &#125;        <span class="hljs-keyword">if</span> (moves.length &lt; <span class="hljs-number">9</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pending&quot;</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Draw&quot;</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tictactoe</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] moves)</span> &#123;        <span class="hljs-comment">// n stands for the size of the board, n = 3 for the current game.</span>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;        <span class="hljs-comment">// Use rows and cols to record the value on each row and each column.</span>        <span class="hljs-comment">// diag1 and diag2 to record value on diagonal or anti-diagonal.</span>        <span class="hljs-type">int</span>[] rows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n], cols = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];        <span class="hljs-type">int</span> <span class="hljs-variable">diag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, anti_diag = <span class="hljs-number">0</span>;                <span class="hljs-comment">// Two players having value of 1 and -1, player_1 with value = 1 places first.</span>        <span class="hljs-type">int</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] move : moves)&#123;            <span class="hljs-comment">// Get the row number and column number for this move.</span>            <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> move[<span class="hljs-number">0</span>], col = move[<span class="hljs-number">1</span>];                        <span class="hljs-comment">// Update the row value and column value.</span>            rows[row] += player;            cols[col] += player;                        <span class="hljs-comment">// If this move is placed on diagonal or anti-diagonal, </span>            <span class="hljs-comment">// we shall update the relative value as well.</span>            <span class="hljs-keyword">if</span> (row == col)&#123;                diag += player;            &#125;            <span class="hljs-keyword">if</span> (row + col == n - <span class="hljs-number">1</span>)&#123;                anti_diag += player;            &#125;                        <span class="hljs-comment">// Check if this move meets any of the winning conditions.</span>            <span class="hljs-keyword">if</span> (Math.abs(rows[row]) == n || Math.abs(cols[col]) == n ||                 Math.abs(diag) == n || Math.abs(anti_diag) == n)&#123;                <span class="hljs-type">return</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span>= <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;A&quot;</span> : <span class="hljs-string">&quot;B&quot;</span>;            &#125;                        <span class="hljs-comment">// If no one wins so far, change to the other player alternatively. </span>            <span class="hljs-comment">// That is from 1 to -1, from -1 to 1.</span>            player *= -<span class="hljs-number">1</span>;        &#125;                <span class="hljs-comment">// If all moves are completed and there is still no result, we shall check if </span>        <span class="hljs-comment">// the grid is full or not. If so, the game ends with draw, otherwise pending.</span>        <span class="hljs-keyword">return</span> moves.length == n * n ? <span class="hljs-string">&quot;Draw&quot;</span> : <span class="hljs-string">&quot;Pending&quot;</span>;    &#125;&#125;</code></pre><h2 id="Sum-of-Subarray-Minimums">Sum of Subarray Minimums</h2><p><a href="https://leetcode.com/problems/sum-of-subarray-minimums/">https://leetcode.com/problems/sum-of-subarray-minimums/</a></p><h3 id="Solutions-37">Solutions</h3><ul><li>count the contributions of each element being the smallest element</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> arr.length;        <span class="hljs-keyword">if</span> (l == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        Stack&lt;Integer&gt; s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();        <span class="hljs-type">long</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        s.add(<span class="hljs-number">0</span>);         <span class="hljs-type">int</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.pow(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= l; i++) &#123;            <span class="hljs-keyword">while</span> (!s.isEmpty() &amp;&amp; arr[s.peek()] &gt; (i == l? <span class="hljs-number">0</span> : arr[i])) &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.pop();                 <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> s.isEmpty() ? -<span class="hljs-number">1</span> :s.peek();                res += (<span class="hljs-type">long</span>)arr[j] * (j - k) * (i - j);                res = res % mod;            &#125;             s.push(i);        &#125;        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)res;    &#125;&#125;</code></pre><h2 id="Minimum-Swaps-to-Group-All-1’s-Together">Minimum Swaps to Group All 1’s Together</h2><p><a href="https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/">https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/</a></p><h3 id="Solutions-38">Solutions</h3><ul><li>sliding window O(n) time, O(1) space</li><li>prefix sum: O(n) time, O(n) space</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">ones</span> <span class="hljs-operator">=</span> Arrays.stream(data).sum();        <span class="hljs-type">int</span> <span class="hljs-variable">cnt_one</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max_one = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (right &lt; data.length) &#123;            <span class="hljs-comment">// updating the number of 1&#x27;s by adding the new element</span>            cnt_one += data[right++];            <span class="hljs-comment">// maintain the length of the window to ones</span>            <span class="hljs-keyword">if</span> (right - left &gt; ones) &#123;                <span class="hljs-comment">// updating the number of 1&#x27;s by removing the oldest element</span>                cnt_one -= data[left++];            &#125;            <span class="hljs-comment">// record the maximum number of 1&#x27;s in the window</span>            max_one = Math.max(max_one, cnt_one);        &#125;        <span class="hljs-keyword">return</span> ones - max_one;    &#125;&#125;</code></pre><pre><div class="caption"><span>My attempt</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minSwaps</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> data.length;        <span class="hljs-type">int</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[l];         sum[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; l; i++) &#123;            sum[i] = data[i] + sum[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">if</span> (sum[l - <span class="hljs-number">1</span>] &lt; <span class="hljs-number">2</span> || sum[l - <span class="hljs-number">1</span>] == l) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= l - sum[l - <span class="hljs-number">1</span>]; i++) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">lastIndex</span> <span class="hljs-operator">=</span> i + sum[l-<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>;            <span class="hljs-type">int</span> <span class="hljs-variable">localMin</span> <span class="hljs-operator">=</span> sum[l - <span class="hljs-number">1</span>] - sum[lastIndex] + sum[i];            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">1</span>) &#123;                localMin--;            &#125;             min = Math.min(localMin, min);        &#125;        <span class="hljs-keyword">return</span> min;     &#125;&#125;</code></pre><h2 id="Maximum-Length-of-Subarray-With-Positive-Product">Maximum Length of Subarray With Positive Product</h2><p><a href="https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/">https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/</a></p><h3 id="Solutions-39">Solutions</h3><ul><li>record the first negative number’s index(my solution)</li><li>dry run</li></ul><pre><div class="caption"><span>My solution</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxLen</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">negatives</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> <span class="hljs-variable">firstNegative</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] == <span class="hljs-number">0</span>) &#123;                negatives = <span class="hljs-number">0</span>;                count = <span class="hljs-number">0</span>;                firstNegative = -<span class="hljs-number">1</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (nums[i] &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">if</span> (firstNegative == -<span class="hljs-number">1</span>) &#123;                    firstNegative = i;                &#125;                negatives++;           &#125;            <span class="hljs-keyword">if</span> (negatives % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &amp;&amp; firstNegative != -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// but there&#x27;s odd number of negatives, count between first negative and current</span>               max = Math.max(max, i - firstNegative);            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (negatives % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;               max = Math.max(max, count + <span class="hljs-number">1</span>);            &#125;            count++;         &#125;        <span class="hljs-keyword">return</span> max;    &#125;&#125;</code></pre><pre><div class="caption"><span>dry run</span><a href="https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/discuss/820072/EASY-soultion-with-DRY-RUN-JAVA">link</a></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMaxLen</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">positive</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, negative = <span class="hljs-number">0</span>;    <span class="hljs-comment">// length of positive and negative results</span>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x : nums) &#123;            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)  &#123;                positive = <span class="hljs-number">0</span>;                negative = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span>) &#123;                positive++;                negative = negative == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span>  : negative+<span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> positive;                positive = negative == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span>  : negative+<span class="hljs-number">1</span>;                negative = temp+<span class="hljs-number">1</span>;            &#125;            ans = Math.max(ans, positive);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre><h2 id="Nested-List-Weight-Sum">Nested List Weight Sum</h2><p><a href="https://leetcode.com/problems/nested-list-weight-sum/">https://leetcode.com/problems/nested-list-weight-sum/</a></p><h3 id="solutions-7">solutions</h3><ul><li>DFS</li><li>BFS</li></ul><pre><div class="caption"><span>Coding tricks</span></div><code class="hljs java">Queue&lt;NestedInteger&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;NestedInteger&gt;(nestedList);queue.addAll(ni.getList());</code></pre><h2 id="Lowest-Common-Ancestor-with-parent-pointer">Lowest Common Ancestor with parent pointer</h2><p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/">https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/</a></p><h3 id="Solutions-40">Solutions</h3><ul><li>S1. Set</li><li>S2. traverse both paths</li></ul><pre><div class="caption"><span>Set Solution</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(Node p, Node q)</span> &#123;        HashSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;            set.add(p.val);            p = p.parent;        &#125;        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (set.contains(q.val)) <span class="hljs-keyword">return</span> q;            q = q.parent;        &#125;        <span class="hljs-keyword">return</span> q;    &#125;&#125;</code></pre><pre><div class="caption"><span>travers both paths solution</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(Node p, Node q)</span> &#123;        <span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> p;        <span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> q;        <span class="hljs-keyword">while</span> (n1 != n2) &#123;            n1 = n1.parent == <span class="hljs-literal">null</span> ? q : n1.parent;            n2 = n2.parent == <span class="hljs-literal">null</span> ? p : n2.parent;        &#125;        <span class="hljs-keyword">return</span> n1;    &#125;&#125;</code></pre><h2 id="Smallest-Common-Region">Smallest Common Region</h2><p><a href="https://leetcode.com/problems/smallest-common-region/">https://leetcode.com/problems/smallest-common-region/</a></p><h3 id="Solutions-41">Solutions</h3><ul><li>use a tree structure to record the parent of each node(my method)</li><li>use a hashMap to record the parent</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;    <span class="hljs-comment">//List&lt;Node&gt; children = new ArrayList&lt;Node&gt;();</span>    <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(String val)</span> &#123;        <span class="hljs-built_in">this</span>.val = val;    &#125;    <span class="hljs-type">Node</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findSmallestRegion</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; regions, String region1, String region2)</span> &#123;        <span class="hljs-comment">// thoughts: create a tree struction and a set of all tree nodes, then find the lowest common ancestor. </span>                HashMap&lt;String, Node&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-comment">// create a tree auto of the regions. </span>        <span class="hljs-keyword">for</span> (List&lt;String&gt; region: regions) &#123;            <span class="hljs-type">Node</span> <span class="hljs-variable">parentNode</span> <span class="hljs-operator">=</span> map.getOrDefault(region.get(<span class="hljs-number">0</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(region.get(<span class="hljs-number">0</span>)));             map.put(region.get(<span class="hljs-number">0</span>), parentNode);            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; region.size(); i++) &#123;                <span class="hljs-type">Node</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> map.getOrDefault(region.get(i), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(region.get(i)));                map.put(region.get(i), child);                <span class="hljs-comment">//parentNode.children.add(child);</span>                child.parent = parentNode;            &#125;        &#125;                <span class="hljs-comment">// find the lowest common ancestor </span>        <span class="hljs-type">Node</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> map.get(region1);        <span class="hljs-type">Node</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> map.get(region2);        HashSet&lt;String&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();        <span class="hljs-keyword">while</span> (n1 != <span class="hljs-literal">null</span>) &#123;            paths.add(n1.val);            n1 = n1.parent;        &#125;        <span class="hljs-keyword">while</span> (n2 != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (paths.contains(n2.val)) <span class="hljs-keyword">return</span> n2.val;             n2 = n2.parent;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">findSmallestRegion</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; regions, String region1, String region2)</span> &#123;        HashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-keyword">for</span> (List&lt;String&gt; region: regions) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; region.size(); i++) &#123;                map.put(region.get(i), region.get(<span class="hljs-number">0</span>));            &#125;        &#125;                <span class="hljs-comment">// find the lowest common ancestor </span>        HashSet&lt;String&gt; paths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();        <span class="hljs-keyword">while</span> (region1 != <span class="hljs-literal">null</span>) &#123;            paths.add(region1);            region1 = map.get(region1);        &#125;        <span class="hljs-keyword">while</span> (region2 != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">if</span> (paths.contains(region2)) <span class="hljs-keyword">return</span> region2;             region2 = map.get(region2);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;</code></pre><pre><div class="caption"><span>without set</span></div><code class="hljs java">Map&lt;String, String&gt; parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<span class="hljs-keyword">for</span>(List&lt;String&gt; rs: regions) &#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; rs.size(); j++) &#123;        parent.put(rs.get(j), rs.get(<span class="hljs-number">0</span>));    &#125;&#125;<span class="hljs-type">String</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> region1, p2 = region2;<span class="hljs-keyword">while</span>(!p1.equals(p2)) &#123;    p1 = parent.getOrDefault(p1, region2);    p2 = parent.getOrDefault(p2, region1);&#125;<span class="hljs-keyword">return</span> p1;</code></pre><h2 id="Cinema-seat-allocation">Cinema seat allocation</h2><p><a href="https://leetcode.com/problems/cinema-seat-allocation/submissions/">https://leetcode.com/problems/cinema-seat-allocation/submissions/</a></p><h3 id="Solutions-42">Solutions</h3><ul><li>only iterate reserved rows</li><li>S1. use a boolean array for each row</li><li>S2. use a set for each row</li><li>S2. use an integer for the row, use bitwise operations</li></ul><pre><div class="caption"><span>1.5</span></div><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    public int <span class="hljs-title function_">maxNumberOfFamilies</span>(<span class="hljs-params">int n, int[][] reservedSeats</span>) &#123;        <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">Integer</span>, boolean[]&gt; reservedRows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-keyword">for</span> (int[] <span class="hljs-attr">seat</span>: reservedSeats) &#123;            boolean[] cols = reservedRows.<span class="hljs-title function_">getOrDefault</span>(seat[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> boolean[<span class="hljs-number">10</span>]);            cols[seat[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;            reservedRows.<span class="hljs-title function_">put</span>(seat[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, cols);        &#125;        <span class="hljs-comment">//System.out.println(reservedRows.size());</span>        int result = <span class="hljs-number">2</span> * (n - reservedRows.<span class="hljs-title function_">size</span>());                <span class="hljs-keyword">for</span> (boolean[] cols : reservedRows.<span class="hljs-title function_">values</span>()) &#123;            <span class="hljs-keyword">if</span> (!cols[<span class="hljs-number">1</span>] &amp;&amp; !cols[<span class="hljs-number">2</span>] &amp;&amp; !cols[<span class="hljs-number">3</span>] &amp;&amp; !cols[<span class="hljs-number">4</span>]) &#123;                cols[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span>;                cols[<span class="hljs-number">4</span>] = <span class="hljs-literal">true</span>;                result++;            &#125;            <span class="hljs-keyword">if</span> (!cols[<span class="hljs-number">3</span>] &amp;&amp; !cols[<span class="hljs-number">4</span>] &amp;&amp; !cols[<span class="hljs-number">5</span>] &amp;&amp; !cols[<span class="hljs-number">6</span>]) &#123;                cols[<span class="hljs-number">5</span>] = <span class="hljs-literal">true</span>;                cols[<span class="hljs-number">6</span>] = <span class="hljs-literal">true</span>;                result++;            &#125;            <span class="hljs-keyword">if</span> (!cols[<span class="hljs-number">5</span>] &amp;&amp; !cols[<span class="hljs-number">6</span>] &amp;&amp; !cols[<span class="hljs-number">7</span>] &amp;&amp; !cols[<span class="hljs-number">8</span>]) &#123;                result++;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;     &#125;&#125;</code></pre><pre><div class="caption"><span>S2</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNumberOfFamilies</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] reservedSeats)</span> &#123;        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; reservedRows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] seat: reservedSeats) &#123;            HashSet&lt;Integer&gt; cols = reservedRows.getOrDefault(seat[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;Integer&gt;());            cols.add(seat[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>);            reservedRows.put(seat[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, cols);        &#125;        <span class="hljs-comment">//System.out.println(reservedRows.size());</span>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * (n - reservedRows.size());                <span class="hljs-keyword">for</span> (HashSet&lt;Integer&gt; cols : reservedRows.values()) &#123;            <span class="hljs-keyword">if</span> (!cols.contains(<span class="hljs-number">1</span>) &amp;&amp; !cols.contains(<span class="hljs-number">2</span>) &amp;&amp; !cols.contains(<span class="hljs-number">3</span>) &amp;&amp; !cols.contains(<span class="hljs-number">4</span>)) &#123;                cols.add(<span class="hljs-number">3</span>);                cols.add(<span class="hljs-number">4</span>);                result++;            &#125;            <span class="hljs-keyword">if</span> (!cols.contains(<span class="hljs-number">3</span>) &amp;&amp; !cols.contains(<span class="hljs-number">4</span>) &amp;&amp; !cols.contains(<span class="hljs-number">5</span>) &amp;&amp; !cols.contains(<span class="hljs-number">6</span>)) &#123;                cols.add(<span class="hljs-number">5</span>);                cols.add(<span class="hljs-number">6</span>);                result++;            &#125;            <span class="hljs-keyword">if</span> (!cols.contains(<span class="hljs-number">5</span>) &amp;&amp; !cols.contains(<span class="hljs-number">6</span>) &amp;&amp; !cols.contains(<span class="hljs-number">7</span>) &amp;&amp; !cols.contains(<span class="hljs-number">8</span>)) &#123;                result++;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;     &#125;&#125;</code></pre><pre><div class="caption"><span>S3</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxNumberOfFamilies</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>[][] reservedSeats)</span> &#123;        HashMap&lt;Integer, Integer&gt; reservedRows = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] seat: reservedSeats) &#123;            reservedRows.put(seat[<span class="hljs-number">0</span>], reservedRows.getOrDefault(seat[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>) | (<span class="hljs-number">1</span> &lt;&lt; seat[<span class="hljs-number">1</span>]));        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * (n - reservedRows.size());                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> cols : reservedRows.values()) &#123;            <span class="hljs-type">boolean</span> <span class="hljs-variable">reserved</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> ((cols &amp; <span class="hljs-number">60</span>) == <span class="hljs-number">0</span>) &#123;                reserved = <span class="hljs-literal">true</span>;                result++;            &#125;            <span class="hljs-keyword">if</span> ((cols &amp; <span class="hljs-number">960</span>) == <span class="hljs-number">0</span>) &#123;                reserved = <span class="hljs-literal">true</span>;                result++;            &#125;            <span class="hljs-keyword">if</span> (!reserved &amp;&amp; (cols &amp; <span class="hljs-number">240</span>) == <span class="hljs-number">0</span>) &#123;                result++;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;     &#125;&#125;</code></pre><h2 id="Distribute-Coins-in-Binary-Tree">Distribute Coins in Binary Tree</h2><p><a href="https://leetcode.com/problems/distribute-coins-in-binary-tree/">https://leetcode.com/problems/distribute-coins-in-binary-tree/</a></p><h2 id="Solutions-43">Solutions</h2><ul><li>divide and conquer, only look at two layers (parent, left, right)</li><li>return excess number of coins up each level, as it levels, it increase the total answer</li><li>record answer on each level.</li><li>overall way of thinking, bottom up solution, move excess number as soon as we find it.</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> ans;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">distributeCoins</span><span class="hljs-params">(TreeNode root)</span> &#123;      dfs(root);          <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode root)</span> &#123;       <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;         <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> dfs(root.left);        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dfs(root.right);        ans += Math.abs(l) + Math.abs(r);        <span class="hljs-keyword">return</span> root.val + l + r  - <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h1>Roblox</h1><h2 id="Design-Browser-History">Design Browser History</h2><p><a href="https://leetcode.com/problems/design-browser-history/">https://leetcode.com/problems/design-browser-history/</a></p><h3 id="Solutions-44">Solutions</h3><ul><li>two stacks<ul><li>trick, while loop two conditions (steps &gt; 0 &amp;&amp; back.size() &gt; 1)</li></ul></li><li>doubly linked list (trickier to write)</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BrowserHistory</span> &#123;    Stack&lt;String&gt; back;    Stack&lt;String&gt; forward;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BrowserHistory</span><span class="hljs-params">(String homepage)</span> &#123;       back = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();        forward = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();         back.add(homepage);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(String url)</span> &#123;       forward.clear();         back.add(url);    &#125;        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">back</span><span class="hljs-params">(<span class="hljs-type">int</span> steps)</span> &#123;       <span class="hljs-type">String</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;         <span class="hljs-keyword">while</span> (steps &gt; <span class="hljs-number">0</span> &amp;&amp; back.size() &gt; <span class="hljs-number">1</span>) &#123;            page = back.pop();            forward.add(page);             steps--;        &#125;        <span class="hljs-keyword">return</span> back.peek();    &#125;        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">forward</span><span class="hljs-params">(<span class="hljs-type">int</span> steps)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">page</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">while</span>(steps &gt; <span class="hljs-number">0</span> &amp;&amp; !forward.isEmpty()) &#123;            page = forward.pop();            back.add(page);            steps--;        &#125;         <span class="hljs-keyword">return</span> back.peek();    &#125;&#125;</code></pre><h2 id="Text-Justification">Text Justification</h2><p><a href="https://leetcode.com/problems/text-justification/">https://leetcode.com/problems/text-justification/</a></p><h3 id="Solutions-45">Solutions</h3><ul><li>Single Responsibility Principle (split into smaller functions)</li><li>It’s a special case when there’s only one word in the row</li><li>last row is different too, because it needs to split into two parts, one appending 1 space, one append all the rest of the spaces</li></ul><pre><div class="caption"><span>my own solution</span></div><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">fullJustify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> maxWidth)</span> &#123;        <span class="hljs-keyword">if</span> (words.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();        List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, wordCharLength = <span class="hljs-number">0</span>;                <span class="hljs-keyword">while</span> (right &lt; words.length) &#123;            <span class="hljs-type">int</span> <span class="hljs-variable">wordLength</span> <span class="hljs-operator">=</span> words[right].length();            <span class="hljs-type">int</span> <span class="hljs-variable">rowLengthWithSpaces</span> <span class="hljs-operator">=</span> wordCharLength + (right - left) - <span class="hljs-number">1</span>;            <span class="hljs-comment">// if previous range plus current word exceeds max width, justify the previous range, and reset the range start</span>            <span class="hljs-keyword">if</span> (rowLengthWithSpaces + <span class="hljs-number">1</span> + wordLength &gt; maxWidth) &#123;                res.add(justify(words, left, right - <span class="hljs-number">1</span>, wordCharLength, maxWidth - rowLengthWithSpaces + (right - left) - <span class="hljs-number">1</span>, maxWidth));                left = right;                wordCharLength = <span class="hljs-number">0</span>;            &#125;             right = right + <span class="hljs-number">1</span>;            wordCharLength += wordLength;        &#125;                <span class="hljs-comment">// add last range to the solution</span>        res.add(lastRowConverting(words, left, words.length - <span class="hljs-number">1</span>, maxWidth));        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-comment">// converting last row includes two parts, </span>    <span class="hljs-comment">// 1. everything before the last word should be concatinate with 1 space</span>    <span class="hljs-comment">// 2. last word should be treated using a normal justify function with a shorter maxWidth</span>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">lastRowConverting</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> maxWidth)</span> &#123;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">lastRow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-comment">// if there&#x27;s more than one word, </span>        <span class="hljs-comment">// 1. append these words with a space to the answer, </span>        <span class="hljs-comment">// 2. maxWidth decrease by the size of the word + space </span>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;            lastRow.append(words[left] + <span class="hljs-string">&quot; &quot;</span>);                maxWidth -= (words[left].length() + <span class="hljs-number">1</span>);            left++;        &#125;        <span class="hljs-type">int</span> <span class="hljs-variable">lastWordLength</span> <span class="hljs-operator">=</span> words[right].length();        <span class="hljs-comment">// justify last word</span>        lastRow.append(justify(words, left, right, lastWordLength, maxWidth - lastWordLength, maxWidth));        <span class="hljs-keyword">return</span> lastRow.toString();    &#125;    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">justify</span><span class="hljs-params">(String[] words, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> charLength,  <span class="hljs-type">int</span> totalSpaces, <span class="hljs-type">int</span> maxWidth)</span> &#123;        <span class="hljs-comment">// space slots</span>        <span class="hljs-type">int</span> <span class="hljs-variable">slots</span> <span class="hljs-operator">=</span> right - left;         <span class="hljs-comment">// if there&#x27;s no slots, that means it&#x27;s one word, so each spacePerSlot should be totalSpace</span>        <span class="hljs-type">int</span> <span class="hljs-variable">spacePerSlot</span> <span class="hljs-operator">=</span> slots == <span class="hljs-number">0</span> ? totalSpaces : totalSpaces / slots;        <span class="hljs-comment">// only valid if there&#x27;s more than one slots</span>        <span class="hljs-type">int</span> <span class="hljs-variable">spaceDiff</span> <span class="hljs-operator">=</span> slots == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : totalSpaces % slots;        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            sb.append(words[left]);             <span class="hljs-comment">// if there&#x27;s more than one slot, don&#x27;t append space to the last word</span>            <span class="hljs-type">int</span> <span class="hljs-variable">spacesAfterThisWord</span> <span class="hljs-operator">=</span> (slots != <span class="hljs-number">0</span> &amp;&amp; left == right) ? <span class="hljs-number">0</span> : spacePerSlot + (spaceDiff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);             <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; spacesAfterThisWord;j++) &#123;                sb.append(<span class="hljs-string">&quot; &quot;</span>);            &#125;            left++;            spaceDiff--;        &#125;         <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre><h2 id="Word-Search">Word Search</h2><p><a href="https://leetcode.com/problems/word-search/">https://leetcode.com/problems/word-search/</a></p><h3 id="Solutions-46">Solutions</h3><ul><li><strong>use existing board instead of extra space, mark visited cell “#”</strong></li><li>check if there’s char that’s not in the board</li><li>check if the word’s length is longer than total num of chars</li><li>check 4 directions at each cell.</li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;        <span class="hljs-keyword">if</span> (word.length() &gt; m * n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        HashSet&lt;Character&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>[] cs : board)             <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : cs)                set.add(c);                 <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word.toCharArray())             <span class="hljs-keyword">if</span> (!set.contains(c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">//actual traverse</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++) &#123;                <span class="hljs-keyword">if</span> (board[i][j] == word.charAt(<span class="hljs-number">0</span>)) &#123;                    <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> dfs(board, word, <span class="hljs-number">0</span>, i, j);                    <span class="hljs-keyword">if</span> (res) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;     &#125;    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>[][] board, String word, <span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> board.length;        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> board[<span class="hljs-number">0</span>].length;       <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || board[i][j] != word.charAt(idx)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (idx == word.length() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                board[i][j] = <span class="hljs-string">&#x27;#&#x27;</span>;        <span class="hljs-type">boolean</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> dfs(board, word, idx + <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>, j);        <span class="hljs-type">boolean</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> dfs(board, word, idx + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>, j);        <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> dfs(board, word, idx + <span class="hljs-number">1</span>, i, j - <span class="hljs-number">1</span>);        <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> dfs(board, word, idx + <span class="hljs-number">1</span>, i, j + <span class="hljs-number">1</span>);        board[i][j] = word.charAt(idx);        <span class="hljs-keyword">return</span> up || down || left || right;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;04/05/2022&lt;/h1&gt;
&lt;h2 id=&quot;Longest-Common-Prefix&quot;&gt;Longest Common Prefix&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefi</summary>
      
    
    
    
    
    <category term="algorithms" scheme="http://example.com/tags/algorithms/"/>
    
    <category term="technical" scheme="http://example.com/tags/technical/"/>
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Trie</title>
    <link href="http://example.com/2022/04/03/Trie/"/>
    <id>http://example.com/2022/04/03/Trie/</id>
    <published>2022-04-03T03:31:32.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<p>##Search Suggestion System: <a href="https://leetcode.com/problems/search-suggestions-system/">https://leetcode.com/problems/search-suggestions-system/</a></p><pre><div class="caption"><span> </span><a href="https://leetcode.com/problems/search-suggestions-system/">link</a></div><code class="hljs java"><span class="hljs-comment">// Custom class Trie with function to get 3 words starting with given prefix</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;    <span class="hljs-comment">// Node definition of a trie</span>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;        <span class="hljs-type">boolean</span> <span class="hljs-variable">isWord</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;        List&lt;Node&gt; children = Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[<span class="hljs-number">26</span>]);    &#125;;    Node Root, curr;    List&lt;String&gt; resultBuffer;    <span class="hljs-comment">// Runs a DFS on trie starting with given prefix and adds all the words in the resultBuffer, limiting result size to 3</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfsWithPrefix</span><span class="hljs-params">(Node curr, String word)</span> &#123;        <span class="hljs-keyword">if</span> (resultBuffer.size() == <span class="hljs-number">3</span>)            <span class="hljs-keyword">return</span>;        <span class="hljs-keyword">if</span> (curr.isWord)            resultBuffer.add(word);        <span class="hljs-comment">// Run DFS on all possible paths.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++)            <span class="hljs-keyword">if</span> (curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>) != <span class="hljs-literal">null</span>)                dfsWithPrefix(curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>), word + c);    &#125;    Trie() &#123;        Root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();    &#125;    <span class="hljs-comment">// Inserts the string in trie.</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-comment">// Points curr to the root of trie.</span>        curr = Root;        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>) == <span class="hljs-literal">null</span>)                curr.children.set(c - <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>());            curr = curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>);        &#125;        <span class="hljs-comment">// Mark this node as a completed word.</span>        curr.isWord = <span class="hljs-literal">true</span>;    &#125;    List&lt;String&gt; <span class="hljs-title function_">getWordsStartingWith</span><span class="hljs-params">(String prefix)</span> &#123;        curr = Root;        resultBuffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();        <span class="hljs-comment">// Move curr to the end of prefix in its trie representation.</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix.toCharArray()) &#123;            <span class="hljs-keyword">if</span> (curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>) == <span class="hljs-literal">null</span>)                <span class="hljs-keyword">return</span> resultBuffer;            curr = curr.children.get(c - <span class="hljs-string">&#x27;a&#x27;</span>);        &#125;        dfsWithPrefix(curr, prefix);        <span class="hljs-keyword">return</span> resultBuffer;    &#125;&#125;;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">suggestedProducts</span><span class="hljs-params">(String[] products,</span><span class="hljs-params">                                         String searchWord)</span> &#123;        <span class="hljs-type">Trie</span> <span class="hljs-variable">trie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trie</span>();        List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-comment">// Add all words to trie.</span>        <span class="hljs-keyword">for</span> (String w : products)            trie.insert(w);        <span class="hljs-type">String</span> <span class="hljs-variable">prefix</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : searchWord.toCharArray()) &#123;            prefix += c;            result.add(trie.getWordsStartingWith(prefix));        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;##Search Suggestion System: &lt;a href=&quot;https://leetcode.com/problems/search-suggestions-system/&quot;&gt;https://leetcode.com/problems/search-sugge</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Binary Search Tree</title>
    <link href="http://example.com/2022/03/18/Binary-Search-Tree/"/>
    <id>http://example.com/2022/03/18/Binary-Search-Tree/</id>
    <published>2022-03-18T06:48:05.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Binary-Search-Tree">Binary Search Tree</h2><h3 id="Keys">Keys</h3><ul><li>pre order traverse</li><li>in order traverse -&gt; sorted array</li><li>post order traverse</li></ul><h3 id="Searching">Searching</h3><p>Recursive</p><pre><code class="hljs plaintext">TREE-SEARCH(x, k)    if x == NIL or k == x.key        return x    if x &lt; x.key        return TREE-SEARCH(x.left, k)    else return TREE-SEARCH(x.right, k)</code></pre><p>Iterative</p><pre><code class="hljs plaintext">ITERATIVE-TREE-SEARCH(x, k)    while x != NIL or k != x.key        if k &lt; x.key            x = x.left        else x = x.right    return x</code></pre><h3 id="minimum-and-maximum">minimum and maximum</h3><pre><code class="hljs plaintext">TREE-MINIMUM(x)    while x != NIL AND x.left != NIL        x = x.left    return x</code></pre><pre><code class="hljs plaintext">TREE-MAXIMUM(x)    while x != NIL AND x.right != NIL        x = x.right    return x</code></pre><h3 id="successor-and-predecessor">successor and predecessor</h3><p>Successor</p><pre><code class="hljs plaintext">TREE-SUCCESSOR(x)    // if this node has a right subtree, just return the minimum in the right subtree    if x!= NIL AND x.right != NIL        return TREE_MINIMUM(x)    // if this node doesn&#x27;t have a right subtree, go up and find the first parent that&#x27;s the left child of its parent     y = x.parent    while y != NIL AND y.right = x        x = y        y = y.plarent    return y</code></pre><p>predecessor</p><pre><code class="hljs plaintext">TREE-PREDECESSOR(x)    // if this node has a left subtree, just return the maximum in the left subtree    if x!= NIL AND x.left != NIL        return TREE_MINIMUM(x)    // if this node doesn&#x27;t have a left subtree, go up and find the first parent that&#x27;s the right child of its parent     y = x.parent    while y != NIL AND y.left = x        x = y        y = y.plarent    return y</code></pre><p>####insertion<br>The key point is to find the NIL location, keep the parent, and then append it to the parent<br>loop invariant: p is always the parent of x</p><ul><li>maintain p is the parent of x</li><li>termination: x is NIL</li></ul><pre><code class="hljs plaintext">TREE-INSERT(T, z)    p = NIL    x = T.root    while x != NIL        p = x.parent        if z.key &gt; x.key            x = x.right        else x = x.left    if p = NIL         T.root = z // Tree is empty    elseif z.key &gt; p.key        p.right = z    else p.left = z</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Binary-Search-Tree&quot;&gt;Binary Search Tree&lt;/h2&gt;
&lt;h3 id=&quot;Keys&quot;&gt;Keys&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;pre order traverse&lt;/li&gt;
&lt;li&gt;in order traverse -&amp;gt; sor</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sum</title>
    <link href="http://example.com/2022/03/06/Sum/"/>
    <id>http://example.com/2022/03/06/Sum/</id>
    <published>2022-03-06T07:40:41.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Two-Sum">Two Sum</h2><p>Keys:</p><ul><li><code>HashMap</code></li><li>O(n)</li></ul><p><em><a href="https://leetcode.com/problems/two-sum/">https://leetcode.com/problems/two-sum/</a></em></p><h2 id="Two-Sum-II-not-allow-duplicates-sorted">Two Sum II (not allow duplicates) (sorted)</h2><p>Keys:</p><ul><li>two pointer</li><li>O(nlog(n))</li></ul><p><em><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/</a></em></p><h2 id="Three-Sum-not-allow-duplicates-sorted-or-not">Three Sum (not allow duplicates) (sorted or not)</h2><p>Keys:</p><ul><li>two pointer<ul><li>outer loop to traverse first occurence</li></ul></li><li>hashset</li><li>no-sort</li><li>O(n^2)</li></ul><p><em><a href="https://leetcode.com/problems/3sum/">https://leetcode.com/problems/3sum/</a></em></p><h2 id="Three-Sum-Smaller">Three Sum Smaller</h2><p><em><a href="https://leetcode.com/problems/3sum-smaller/">https://leetcode.com/problems/3sum-smaller/</a></em> (To be reviewed)</p><h2 id="Three-Sum-Closest">Three Sum Closest</h2><p><em><a href="https://leetcode.com/problems/3sum-closest/">https://leetcode.com/problems/3sum-closest/</a></em> (To be reviewed)</p><h2 id="Four-Sum">Four Sum</h2><p><em><a href="https://leetcode.com/problems/4sum/">https://leetcode.com/problems/4sum/</a></em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Two-Sum&quot;&gt;Two Sum&lt;/h2&gt;
&lt;p&gt;Keys:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HashMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://leetcode.com/probl</summary>
      
    
    
    
    
    <category term="sum" scheme="http://example.com/tags/sum/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search</title>
    <link href="http://example.com/2022/03/06/Binary-Search/"/>
    <id>http://example.com/2022/03/06/Binary-Search/</id>
    <published>2022-03-06T04:19:39.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concepts">Concepts</h2><h2 id="Key">Key</h2><ul><li>get rid of a side that’s not what we are looking for</li><li>whether you can git rid of the border depending on if the border might be the final answer</li><li>use the smallest sample size(size = 1) to test if the condition allows entering the while loop, and test if the condition allows exiting the loop</li></ul><h2 id="Questions">Questions</h2><ul><li>closet to a target number(stop at two elements)</li><li>kth closet to a target number<ul><li>find the closest, then traverse left or right</li></ul></li><li>find the first occurrence of a number<ul><li>1,2,2,2 find 2;</li><li>stop at two elements</li><li>don’t stop at the target, keep moving the left: <code>l = m</code>, not <code>m - 1</code> because can’t get rid of m</li></ul></li><li>sorted array of unknown size<ul><li>double the range to find the end index first</li><li>then try to find it in the found range</li></ul></li><li>maximum profit in job scheduling(hard): <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/">https://leetcode.com/problems/maximum-profit-in-job-scheduling/</a><ul><li>dp + binary search. top down + bottom up.</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Concepts&quot;&gt;Concepts&lt;/h2&gt;
&lt;h2 id=&quot;Key&quot;&gt;Key&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;get rid of a side that’s not what we are looking for&lt;/li&gt;
&lt;li&gt;whether you can</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Fundamental</title>
    <link href="http://example.com/2022/03/06/Fundamental/"/>
    <id>http://example.com/2022/03/06/Fundamental/</id>
    <published>2022-03-06T01:51:47.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Loop-Invariants">Loop Invariants</h3><ul><li><em>Initialization</em>: It’s true prior to the first iteration of the loop(variable initializations before the loop)</li><li><em>Maintenance</em>: If it’s true before an iteration of the loop, it remains true before the next iteration(logic inside the loop)</li><li><em>Termination</em>: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct(condition to stop the loop)</li></ul><p>Initialization -&gt; base case, Maintenance -&gt; inductive step, Termination -&gt; Condition; Termination usually involves loop invariants. In math, inductive steps carries on infinitely, but in here, we stop the loop when the termination happens.</p><p><strong>Notes:</strong> practice always come up with the loop invariants before you start writing the loop.</p><h3 id="Running-time">Running time</h3><p>Big O notation</p><h3 id="Worst-cast-and-average-case-analysis">Worst-cast and average-case analysis</h3><p>Worst-Case</p><ul><li>an upper bound on teh running time</li><li>for some algorithms, the worst case occurs fairly often. Like searching a database for a piece of missing data.</li></ul><h3 id="Designing-Algorithms">Designing Algorithms</h3><p>Principles:</p><ul><li>Incremental: e.g.: insertion sort, insert single element into its proper place.</li><li>Divide and conquer:<ul><li><em>recurisve</em> is from this principle</li><li>three steps:<ul><li><strong>Divide</strong> into smaller subproblems</li><li><strong>Conquer</strong> the subproblems by solving them recursively</li><li><strong>Combine</strong> the solution</li></ul></li><li>analysis<ul><li><strong>recurrence equation</strong> : running time of a recursion call.</li></ul></li><li>binary search</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Loop-Invariants&quot;&gt;Loop Invariants&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Initialization&lt;/em&gt;: It’s true prior to the first iteration of the loop(variable </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sorting</title>
    <link href="http://example.com/2022/03/06/Sorting/"/>
    <id>http://example.com/2022/03/06/Sorting/</id>
    <published>2022-03-06T00:53:41.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<h1>Insertion Sort</h1><h2 id="Keys-2">Keys</h2><ul><li>playing card</li><li>sorted part + unsorted part</li><li>insert in sorted array</li></ul><h2 id="Code">Code</h2><h3 id="array">array</h3><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">class</span> <span class="hljs-title class_">GFG</span>&#123;<span class="hljs-comment">// Function to sort an array using insertion sort</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-type">int</span> i, key, j;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)&#123;key = arr[i];j = i - <span class="hljs-number">1</span>;<span class="hljs-comment">// Move elements of arr[0..i-1],</span><span class="hljs-comment">// that are greater than key to</span><span class="hljs-comment">// one position ahead of their</span><span class="hljs-comment">// current position</span><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key)&#123;arr[j + <span class="hljs-number">1</span>] = arr[j];j = j - <span class="hljs-number">1</span>;&#125;arr[j + <span class="hljs-number">1</span>] = key;&#125;&#125;<span class="hljs-comment">// Function to print an array of size N</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-comment">// Print the array</span><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);&#125;System.out.println();&#125;<span class="hljs-comment">// Driver code</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> &#125;;<span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> arr.length;<span class="hljs-comment">// Function Call</span>insertionSort(arr, N);printArray(arr, N);&#125;&#125;</code></pre><h3 id="Singly-linkedlist">Singly linkedlist</h3><ul><li>My solution (not optimal, hard to remember)</li></ul><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * public class ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     ListNode next;</span><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><span class="hljs-comment"> * &#125;</span><span class="hljs-comment"> */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertionSortList</span><span class="hljs-params">(ListNode head)</span> &#123;        <span class="hljs-comment">//base case:</span>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;       <span class="hljs-comment">// loop invariants: </span>        <span class="hljs-comment">// for each i in [0, n], list before head[i] is sorted, after is not sorted. </span>        <span class="hljs-comment">// initialization: i = 1, becasue head[0] is already sorted by itself</span>        <span class="hljs-comment">// maintenance: as i++, we need to insert head[i] into it&#x27;s right place.</span>        <span class="hljs-comment">// temination condition: when it passes all the elements</span>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> head.next;        <span class="hljs-type">int</span> <span class="hljs-variable">localTraverseCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">localPrev</span> <span class="hljs-operator">=</span> head;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">headCopy</span> <span class="hljs-operator">=</span> head;                <span class="hljs-keyword">while</span>(local != <span class="hljs-literal">null</span>) &#123;             <span class="hljs-comment">// break current node</span>              localPrev.next = local.next;            <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> local.next;                       <span class="hljs-comment">// if it&#x27;s the smallest </span>          <span class="hljs-keyword">if</span> (local.val &lt; headCopy.val) &#123;              local.next = headCopy;               headCopy = local;          &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// loop through the first part to insert the node </span>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">insertTraverse</span> <span class="hljs-operator">=</span> headCopy;            <span class="hljs-type">int</span> <span class="hljs-variable">insertTraverseCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                <span class="hljs-comment">//local invariants: insertTraverse.val is smaller than local.val but insertTraverse.next.val is bigger</span>                <span class="hljs-keyword">while</span> (insertTraverseCount &lt; localTraverseCount &amp;&amp; insertTraverse.val &lt; local.val &amp;&amp; insertTraverse.next.val &lt; local.val) &#123;                  insertTraverse = insertTraverse.next;                      insertTraverseCount++;                &#125;                <span class="hljs-comment">// termination: it&#x27;s own place, or found a node whose .next.val is bigger</span>                <span class="hljs-comment">// insert local after insertTraverse</span>                   <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> insertTraverse.next;                 insertTraverse.next = local;                local.next = temp;                <span class="hljs-keyword">if</span> (insertTraverseCount == localTraverseCount) &#123;                   localPrev = local;                  &#125;              &#125;               localTraverseCount++;            local = next;        &#125;                <span class="hljs-keyword">return</span> headCopy;    &#125;&#125;</code></pre><ul><li>given solutions:</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertionSortList</span><span class="hljs-params">(ListNode head)</span> &#123;    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();    <span class="hljs-type">ListNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> head;    <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// At each iteration, we insert an element into the resulting list.</span>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> dummy;        <span class="hljs-comment">// find the position to insert the current node</span>        <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-literal">null</span> &amp;&amp; prev.next.val &lt; curr.val) &#123;            prev = prev.next;        &#125;        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> curr.next;        <span class="hljs-comment">// insert the current node to the new list</span>        curr.next = prev.next;        prev.next = curr;        <span class="hljs-comment">// moving on to the next iteration</span>        curr = next;    &#125;    <span class="hljs-keyword">return</span> dummy.next;&#125;</code></pre><p><em><a href="https://leetcode.com/problems/insertion-sort-list/">https://leetcode.com/problems/insertion-sort-list/</a></em></p><h1>Selection Sort</h1><h2 id="Keys-3">Keys</h2><ul><li>for for loop</li><li><code>swap(i, minSoFar)</code></li></ul><h2 id="Examples">Examples</h2><ul><li>sort an array with two stacks</li><li>sort an array with one stack</li></ul><h2 id="Code-2">Code</h2><h3 id="selection-sort">selection sort</h3><pre><code class="hljs java"><span class="hljs-comment">// Selection sort in Java</span><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectionSort</span> &#123;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> array.length;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; step &lt; size - <span class="hljs-number">1</span>; step++) &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">min_idx</span> <span class="hljs-operator">=</span> step;      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> step + <span class="hljs-number">1</span>; i &lt; size; i++) &#123;        <span class="hljs-comment">// To sort in descending order, change &gt; to &lt; in this line.</span>        <span class="hljs-comment">// Select the minimum element in each loop.</span>        <span class="hljs-keyword">if</span> (array[i] &lt; array[min_idx]) &#123;          min_idx = i;        &#125;      &#125;      <span class="hljs-comment">// put min at the correct position</span>      swap(array, min_idx, step);    &#125;  &#125;  <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(array, x, y)</span> &#123;      <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[x];      array[x] = array[y];      array[y] = temp;  &#125;  <span class="hljs-comment">// driver code</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;    <span class="hljs-type">int</span>[] data = &#123; <span class="hljs-number">20</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2</span> &#125;;    <span class="hljs-type">SelectionSort</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionSort</span>();    ss.selectionSort(data);    System.out.println(<span class="hljs-string">&quot;Sorted Array in Ascending Order: &quot;</span>);    System.out.println(Arrays.toString(data));  &#125;&#125;</code></pre><h3 id="stacks">stacks</h3><pre><code class="hljs java"><span class="hljs-comment">// Java program to sort an</span><span class="hljs-comment">// array using stack</span><span class="hljs-keyword">import</span> java.io.*;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">class</span> <span class="hljs-title class_">GFG</span>&#123;<span class="hljs-comment">// This function return the sorted stack</span><span class="hljs-keyword">static</span> Stack&lt;Integer&gt; <span class="hljs-title function_">sortStack</span><span class="hljs-params">(Stack&lt;Integer&gt; input)</span>&#123;Stack&lt;Integer&gt; tmpStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<span class="hljs-keyword">while</span> (!input.empty())&#123;<span class="hljs-comment">// pop out the first element</span><span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> input.peek();input.pop();<span class="hljs-comment">// while temporary stack is not empty and top of stack is smaller than temp</span><span class="hljs-keyword">while</span> (!tmpStack.empty() &amp;&amp; tmpStack.peek() &lt; tmp)&#123;<span class="hljs-comment">// pop from temporary stack and push it to the input stack</span>input.push(tmpStack.peek());tmpStack.pop();&#125;<span class="hljs-comment">// push tmp in temporary of stack</span>tmpStack.push(tmp);&#125;<span class="hljs-keyword">return</span> tmpStack;&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortArrayUsingStacks</span><span class="hljs-params">(<span class="hljs-type">int</span> []arr, <span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">// push array elements</span><span class="hljs-comment">// to stack</span>Stack&lt;Integer&gt; input = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;Integer&gt;();<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)input.push(arr[i]);<span class="hljs-comment">// Sort the temporary stack</span>Stack&lt;Integer&gt; tmpStack = sortStack(input);<span class="hljs-comment">// Put stack elements in arr[]</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;arr[i] = tmpStack.peek();tmpStack.pop();&#125;&#125;<span class="hljs-comment">// Driver Code</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<span class="hljs-type">int</span> []arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">45</span>&#125;;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;sortArrayUsingStacks(arr, n);<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);&#125;&#125;</code></pre><p><em><a href="https://www.geeksforgeeks.org/sorting-array-using-stacks/">https://www.geeksforgeeks.org/sorting-array-using-stacks/</a></em></p><h1>Merge Sort</h1><p><img src="/2022/03/06/Sorting/Merge-Sort-Tutorial.png" alt="Merge Sort"></p><h2 id="Keys-4">Keys</h2><ul><li>Divide and conquer</li><li>Divide, Conquer, Combine</li></ul><h2 id="Psudo-code">Psudo code</h2><pre><code class="hljs plaintext">MergeSort(A, p, r)if p &lt; r    q = [p + r] / 2    MergeSort(A, p, q)    MergeSort(A, q + 1, r)    Merge(A, p, q, r)Merge(A, p, q, r)</code></pre><h2 id="Code-3">Code</h2><pre><code class="hljs java"><span class="hljs-comment">/* Java program for Merge Sort */</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MergeSort</span>&#123;<span class="hljs-comment">// Merges two subarrays of arr[].</span><span class="hljs-comment">// First subarray is arr[l..m]</span><span class="hljs-comment">// Second subarray is arr[m+1..r]</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> r)</span>&#123;<span class="hljs-comment">// Find sizes of two subarrays to be merged</span><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> m - l + <span class="hljs-number">1</span>;<span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> r - m;<span class="hljs-comment">/* Create temp arrays */</span><span class="hljs-type">int</span> L[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n1];<span class="hljs-type">int</span> R[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n2];<span class="hljs-comment">/*Copy data to temp arrays*/</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n1; ++i)L[i] = arr[l + i];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n2; ++j)R[j] = arr[m + <span class="hljs-number">1</span> + j];<span class="hljs-comment">/* Merge the temp arrays */</span><span class="hljs-comment">// Initial indexes of first and second subarrays</span><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<span class="hljs-comment">// Initial index of merged subarray array</span><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> l;<span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) &#123;arr[k] = L[i];i++;&#125;<span class="hljs-keyword">else</span> &#123;arr[k] = R[j];j++;&#125;k++;&#125;<span class="hljs-comment">/* Copy remaining elements of L[] if any */</span><span class="hljs-keyword">while</span> (i &lt; n1) &#123;arr[k] = L[i];i++;k++;&#125;<span class="hljs-comment">/* Copy remaining elements of R[] if any */</span><span class="hljs-keyword">while</span> (j &lt; n2) &#123;arr[k] = R[j];j++;k++;&#125;&#125;<span class="hljs-comment">// Main function that sorts arr[l..r] using</span><span class="hljs-comment">// merge()</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>&#123;<span class="hljs-keyword">if</span> (l &lt; r) &#123;<span class="hljs-comment">// Find the middle point</span><span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span>l+ (r-l)/<span class="hljs-number">2</span>;<span class="hljs-comment">// Sort first and second halves</span>sort(arr, l, m);sort(arr, m + <span class="hljs-number">1</span>, r);<span class="hljs-comment">// Merge the sorted halves</span>merge(arr, l, m, r);&#125;&#125;<span class="hljs-comment">/* A utility function to print array of size n */</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span>&#123;<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> arr.length;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)System.out.print(arr[i] + <span class="hljs-string">&quot; &quot;</span>);System.out.println();&#125;<span class="hljs-comment">// Driver code</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">12</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span> &#125;;System.out.println(<span class="hljs-string">&quot;Given Array&quot;</span>);printArray(arr);<span class="hljs-type">MergeSort</span> <span class="hljs-variable">ob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MergeSort</span>();ob.sort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);System.out.println(<span class="hljs-string">&quot;\nSorted array&quot;</span>);printArray(arr);&#125;&#125;</code></pre><p><em><a href="https://www.geeksforgeeks.org/merge-sort/">https://www.geeksforgeeks.org/merge-sort/</a></em></p><p>Merge Two sorted arrays, in place.</p><p>Keys:</p><ul><li>principle: three pointers</li><li>in order not to override, it’s best to move from right to left. so the condition need to check which bigger instead of who’s smaller</li><li>my first thought was moving all the elements of nums1 to the end and go from left. it works too, but there’s more to write.</li><li>how to write the condition is worth memorizing</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> m + n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;        <span class="hljs-comment">// positive condition: when will we need to </span>        <span class="hljs-comment">// swap with nums1</span>        <span class="hljs-comment">// 1. when nums1 still has elements and nums2 is out</span>        <span class="hljs-comment">// 2. when nums1 still has elements and nums1[p] &gt; nums2[q]</span>        <span class="hljs-comment">// notes: it&#x27;s &quot;&gt;&quot; because we go from right to left. </span>        <span class="hljs-keyword">if</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; (q &lt; <span class="hljs-number">0</span> || (nums1[p] &gt; nums2[q]))) &#123;            nums1[i] = nums1[p--];            <span class="hljs-keyword">continue</span>;        &#125;        nums1[i] = nums2[q--];    &#125;&#125;</code></pre><p><em><a href="https://leetcode.com/problems/merge-sorted-array/">https://leetcode.com/problems/merge-sorted-array/</a></em></p><h1>Heapsort</h1><p>Keys:</p><ul><li>heapify the whole array</li><li>keep swapping with the largest element</li></ul><p>Can be used to implement a priority queue<br>Time Complexity: O(nlog(n))</p><h1>Quick Sort</h1><h2 id="Psudo">Psudo</h2><details>     <summary>Psudo</summary><pre><code class="hljs plaintext">PARTITION(A, p, r)  x = A[r] i = p - 1 for j = p to r - 1    if (A[j] &lt;= x)        i = i + 1        swap(A[i], A[j]) swap(A[r], A[i+1]) return i+1;//--------Normal quicksort--------QUICKSORT(A, p, r) if p &lt; r     q = PARTATION(A, p, r)    QUICKSORT(A, p, q -1)     QUICKSORT(A, q + 1, r) //--------Tail quicksort--------TAIL-RECURSIVE-QUICKSORT(A, p, r) while(p &lt; r)     q = PARTITION(A, p, r)    TAIL-RECURSIVE-QUICKSORT(A, p, q - 1)    p = q + 1//--------Tail quicksort with logn most depth:sub-call on the smaller half--------TAIL-RECURSIVE-QUICKSORT(A, p, r) while(p &lt; r)     q = PARTITION(A, p, r)    if (p - q &gt; r - p)       TAIL-RECURSIVE-QUICKSORT(A, p, q - 1)      p = q + 1    else      TAIL-RECURSIVE-QUICKSORT(A, q + 1, r)      r = q - 1</code></pre></details><h2 id="Sorting-related-problems">Sorting related problems</h2><p>Merge Intervals</p><ul><li><a href="https://leetcode.com/problems/merge-intervals/">https://leetcode.com/problems/merge-intervals/</a></li><li>Keys:<ul><li>sort the array based on the first value, then use a stack to linear scan back.</li><li><details> </li></ul>  <summary> My attempt</summary></li></ul><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;        <span class="hljs-comment">// sort intervals based on the start time</span>        <span class="hljs-comment">// quick sort it</span>        quicksort(intervals, <span class="hljs-number">0</span>, intervals.length - <span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] interval : intervals) &#123;          System.out.println(interval[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; &quot;</span> + interval[<span class="hljs-number">1</span>]);        &#125;        Stack&lt;<span class="hljs-type">int</span>[]&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] interval: intervals) &#123;            <span class="hljs-keyword">if</span> (stack.isEmpty() || interval[<span class="hljs-number">0</span>] &gt; stack.peek()[<span class="hljs-number">1</span>]) &#123;                stack.push(interval);            &#125; <span class="hljs-keyword">else</span> &#123;               stack.peek()[<span class="hljs-number">1</span>] = Math.max(interval[<span class="hljs-number">1</span>],stack.peek()[<span class="hljs-number">1</span>]);             &#125;        &#125;        <span class="hljs-type">int</span>[][] ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[stack.size()][<span class="hljs-number">2</span>];        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> stack.size() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;            ret[i--] = stack.pop();        &#125;       <span class="hljs-keyword">return</span> ret;     &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quicksort</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> r)</span> &#123;       <span class="hljs-keyword">while</span> (q &lt; r)  &#123;           <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> partition(intervals, q, r);           <span class="hljs-keyword">if</span> (q - p &lt; r - p) &#123;             quicksort(intervals, q, p - <span class="hljs-number">1</span>);             q = p + <span class="hljs-number">1</span>;           &#125; <span class="hljs-keyword">else</span> &#123;             quicksort(intervals, p + <span class="hljs-number">1</span>, r);             r = p - <span class="hljs-number">1</span>;           &#125;       &#125;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span> q, <span class="hljs-type">int</span> r)</span> &#123;       <span class="hljs-type">int</span>[] pi = intervals[r];       <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> q - <span class="hljs-number">1</span>;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> q; j &lt; r; j++) &#123;            <span class="hljs-keyword">if</span> (intervals[j][<span class="hljs-number">0</span>] &lt;= pi[<span class="hljs-number">0</span>]) &#123;                i++;                swap(intervals, i, j);            &#125;        &#125;        swap(intervals, i + <span class="hljs-number">1</span>, r);        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] intervals, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;        <span class="hljs-type">int</span>[] temp = intervals[i];        intervals[i] = intervals[j];        intervals[j] = temp;    &#125;&#125;</code></pre>   </details>  ]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Insertion Sort&lt;/h1&gt;
&lt;h2 id=&quot;Keys-2&quot;&gt;Keys&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;playing card&lt;/li&gt;
&lt;li&gt;sorted part + unsorted part&lt;/li&gt;
&lt;li&gt;insert in sorted array</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Start My Algorithm Journey</title>
    <link href="http://example.com/2022/03/05/start/"/>
    <id>http://example.com/2022/03/05/start/</id>
    <published>2022-03-05T23:12:14.000Z</published>
    <updated>2022-04-28T01:26:39.527Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始准备刷题，学习算法。 这个blog用来记录我的历程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始准备刷题，学习算法。 这个blog用来记录我的历程。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
